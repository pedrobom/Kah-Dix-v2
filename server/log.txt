
> server@1.0.0 start
> nodemon src/index.js

[33m[nodemon] 2.0.4[39m
[33m[nodemon] to restart at any time, enter `rs`[39m
[33m[nodemon] watching path(s): *.*[39m
[33m[nodemon] watching extensions: js,mjs,json[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [n9mLi3huwud6RB5gAAAA]
Conteúdo de handshake da socket [n9mLi3huwud6RB5gAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3A_XmuKXX7Ouwk_D7z77YWGYkS79Im-Lrp.ig%2BNWToICC4mJe8WU7bcK5yuiBYWPqVAcDEHNwpKl2Y; io=FOqstR-1OP2DPXPvAAAA"
  },
  "time": "Sun Feb 14 2021 17:20:16 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334016195,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYCt2S",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYCt2S"
  }
}
Conteúdo da sessão da socket [n9mLi3huwud6RB5gAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:20:16.192Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [n9mLi3huwud6RB5gAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 67,
    updatedAt: 2021-02-14T20:20:16.247Z,
    createdAt: 2021-02-14T20:20:16.247Z,
    name: null
  },
  _previousDataValues: {
    id: 67,
    name: null,
    createdAt: 2021-02-14T20:20:16.247Z,
    updatedAt: 2021-02-14T20:20:16.247Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 67
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [n9mLi3huwud6RB5gAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:20:16.192Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 67
}
Ligando o usuário [67] ao socket [67]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 67 AND (("Socket"."id" = 67)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (67)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 67;
Usuário [67] ligado ao socket [67], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 67;
Enviando dados de sessão para o usuário [67]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 67 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 67 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [67] tentando entrar com nome [pim ] na sala com nome [neo_sala_1]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 67 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 67 ) ON "Room"."id" = "players"."roomId";
Usuário [67] trocou o nome de [null] para [pim ]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_1]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_1' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 8,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_1',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T20:12:55.698Z,
    updatedAt: 2021-02-14T20:12:55.698Z,
    hostId: 65,
    players: [ [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 8,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_1',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T20:12:55.698Z,
    updatedAt: 2021-02-14T20:12:55.698Z,
    hostId: 65,
    players: [ [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_1' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 65,
      name: 'Pim',
      createdAt: 2021-02-14T20:12:47.334Z,
      updatedAt: 2021-02-14T20:12:55.679Z
    },
    _previousDataValues: {
      id: 65,
      name: 'Pim',
      createdAt: 2021-02-14T20:12:47.334Z,
      updatedAt: 2021-02-14T20:12:55.679Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_1] que o usuário [67] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 8 AND "RoomPlayer"."userId" = 67);
Tentando adicionar usuário [pim ] na sala [neo_sala_1]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'pim ' WHERE "RoomPlayer"."roomId" = 8;
Adicionando usuário [67] à sala [neo_sala_1]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_1
Adicionando usuário [67] para a sala [neo_sala_1] no socket
Enviando mensagem do sistema [pim  tá na área!] para a sala [neo_sala_1]
Emitindo roomData para os sockets conectados na sala [neo_sala_1]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 8;
emitindo RoomData para todos os sockets do usuário [66]
emitindo roomData para o socket [e68gR5j0eozqzm0QAAAB] do usuário [66]
emitindo RoomData para todos os sockets do usuário [67]
emitindo roomData para o socket [n9mLi3huwud6RB5gAAAA] do usuário [67]
emitindo RoomData para todos os sockets do usuário [65]
Pegando player do usuário [67] na sala [8]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 8 AND "RoomPlayer"."userId" = 67);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [J6eyn0hhelzwOXLfAAAB]
Conteúdo de handshake da socket [J6eyn0hhelzwOXLfAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/"
  },
  "time": "Sun Feb 14 2021 17:21:31 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334091459,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYD9R1",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYD9R1"
  }
}
Conteúdo da sessão da socket [J6eyn0hhelzwOXLfAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:21:31.459Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [J6eyn0hhelzwOXLfAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 68,
    updatedAt: 2021-02-14T20:21:31.468Z,
    createdAt: 2021-02-14T20:21:31.468Z,
    name: null
  },
  _previousDataValues: {
    id: 68,
    name: null,
    createdAt: 2021-02-14T20:21:31.468Z,
    updatedAt: 2021-02-14T20:21:31.468Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 68
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [J6eyn0hhelzwOXLfAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:21:31.459Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 68
}
Ligando o usuário [68] ao socket [68]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 68 AND (("Socket"."id" = 68)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (68)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 68;
Usuário [68] ligado ao socket [68], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 68;
Enviando dados de sessão para o usuário [68]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 68 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 68 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [68] tentando entrar com nome [Vito] na sala com nome [neo_sala_1]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 68 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 68 ) ON "Room"."id" = "players"."roomId";
Usuário [68] trocou o nome de [null] para [Vito]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_1]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_1' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 8,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_1',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T20:12:55.698Z,
    updatedAt: 2021-02-14T20:12:55.698Z,
    hostId: 65,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 8,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_1',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T20:12:55.698Z,
    updatedAt: 2021-02-14T20:12:55.698Z,
    hostId: 65,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_1' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 65,
      name: 'Pim',
      createdAt: 2021-02-14T20:12:47.334Z,
      updatedAt: 2021-02-14T20:12:55.679Z
    },
    _previousDataValues: {
      id: 65,
      name: 'Pim',
      createdAt: 2021-02-14T20:12:47.334Z,
      updatedAt: 2021-02-14T20:12:55.679Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_1] que o usuário [68] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 8 AND "RoomPlayer"."userId" = 68);
Tentando adicionar usuário [Vito] na sala [neo_sala_1]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Vito' WHERE "RoomPlayer"."roomId" = 8;
Adicionando usuário [68] à sala [neo_sala_1]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_1
Adicionando usuário [68] para a sala [neo_sala_1] no socket
Enviando mensagem do sistema [Vito tá na área!] para a sala [neo_sala_1]
Emitindo roomData para os sockets conectados na sala [neo_sala_1]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 8;
emitindo RoomData para todos os sockets do usuário [68]
emitindo roomData para o socket [J6eyn0hhelzwOXLfAAAB] do usuário [68]
emitindo RoomData para todos os sockets do usuário [66]
emitindo roomData para o socket [e68gR5j0eozqzm0QAAAB] do usuário [66]
emitindo RoomData para todos os sockets do usuário [67]
emitindo roomData para o socket [n9mLi3huwud6RB5gAAAA] do usuário [67]
emitindo RoomData para todos os sockets do usuário [65]
Pegando player do usuário [68] na sala [8]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 8 AND "RoomPlayer"."userId" = 68);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [eAqwMr8HAxQI3lZHAAAC]
Conteúdo de handshake da socket [eAqwMr8HAxQI3lZHAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=J6eyn0hhelzwOXLfAAAB; connect.sid=s%3Ao1n3PE0DLufRH9oaFBQ-AUXe-EGW3ilF.2JxufyzYI4xHexsrVX0dQAKGQKqzvk3uqf5GDobwxEw"
  },
  "time": "Sun Feb 14 2021 17:22:17 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334137690,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYDKjM",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYDKjM"
  }
}
Conteúdo da sessão da socket [eAqwMr8HAxQI3lZHAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:22:17.690Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 68
}
Executing (default): SELECT "id", "name", "createdAt", "updatedAt" FROM "users" AS "User" WHERE "User"."id" = 68;
Detectei o usuário com id [68] para a socket com id [eAqwMr8HAxQI3lZHAAAC]
verificando nome da sala do jogador [Vito] se ele estiver em uma
O usuário [68] já está na sala [undefined], vou mandar os dados da sala para ele!
adicionando socket.id [eAqwMr8HAxQI3lZHAAAC] na socketRoom [undefined]
Emitindo roomData para os sockets conectados na sala [undefined]
Ligando o usuário [68] ao socket [69]
[31m[nodemon] app crashed - waiting for file changes before starting...[39m

> server@1.0.0 start
> nodemon src/index.js

[33m[nodemon] 2.0.4[39m
[33m[nodemon] to restart at any time, enter `rs`[39m
[33m[nodemon] watching path(s): *.*[39m
[33m[nodemon] watching extensions: js,mjs,json[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [_iTtJZ30-AEbCE_HAAAA]
Conteúdo de handshake da socket [_iTtJZ30-AEbCE_HAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AHpgNPbtk2gvi8D7c6EJ1dxIWb9x0BI1B.OMNwtsxjOW2231y7Xo0y%2BWV8KiBNDjP0Wij4NKlk7X8; io=n9mLi3huwud6RB5gAAAA"
  },
  "time": "Sun Feb 14 2021 17:24:00 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334240513,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYDjpK",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYDjpK"
  }
}
Conteúdo da sessão da socket [_iTtJZ30-AEbCE_HAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:24:00.509Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [_iTtJZ30-AEbCE_HAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 69,
    updatedAt: 2021-02-14T20:24:00.568Z,
    createdAt: 2021-02-14T20:24:00.568Z,
    name: null
  },
  _previousDataValues: {
    id: 69,
    name: null,
    createdAt: 2021-02-14T20:24:00.568Z,
    updatedAt: 2021-02-14T20:24:00.568Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 69
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [_iTtJZ30-AEbCE_HAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:24:00.509Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 69
}
Ligando o usuário [69] ao socket [70]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 69 AND (("Socket"."id" = 70)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (70)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 69;
Usuário [69] ligado ao socket [70], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 69;
Enviando dados de sessão para o usuário [69]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 69 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 69 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [_LpXNQmYfzdUqIfSAAAB]
Conteúdo de handshake da socket [_LpXNQmYfzdUqIfSAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=eAqwMr8HAxQI3lZHAAAC; connect.sid=s%3Ao1n3PE0DLufRH9oaFBQ-AUXe-EGW3ilF.2JxufyzYI4xHexsrVX0dQAKGQKqzvk3uqf5GDobwxEw"
  },
  "time": "Sun Feb 14 2021 17:24:00 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334240961,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYDjwu",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYDjwu"
  }
}
Conteúdo da sessão da socket [_LpXNQmYfzdUqIfSAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:24:00.960Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [_LpXNQmYfzdUqIfSAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 70,
    updatedAt: 2021-02-14T20:24:00.988Z,
    createdAt: 2021-02-14T20:24:00.988Z,
    name: null
  },
  _previousDataValues: {
    id: 70,
    name: null,
    createdAt: 2021-02-14T20:24:00.988Z,
    updatedAt: 2021-02-14T20:24:00.988Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 70
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [_LpXNQmYfzdUqIfSAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:24:00.960Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 70
}
Ligando o usuário [70] ao socket [71]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 70 AND (("Socket"."id" = 71)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (71)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 70;
Usuário [70] ligado ao socket [71], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 70;
Enviando dados de sessão para o usuário [70]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 70 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 70 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [N0KGsF8c3vXDwPilAAAC]
Conteúdo de handshake da socket [N0KGsF8c3vXDwPilAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=_LpXNQmYfzdUqIfSAAAB; connect.sid=s%3AaXUb9axPc88KG_lSQiLLebZe_KYZnBRT.djxKOOpNy8V61hB8Cod1H1tJu%2B51hrHrl3y0G8kJi1k"
  },
  "time": "Sun Feb 14 2021 17:24:01 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334241190,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYDj-S",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYDj-S"
  }
}
Conteúdo da sessão da socket [N0KGsF8c3vXDwPilAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:24:01.190Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [N0KGsF8c3vXDwPilAAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 71,
    updatedAt: 2021-02-14T20:24:01.209Z,
    createdAt: 2021-02-14T20:24:01.209Z,
    name: null
  },
  _previousDataValues: {
    id: 71,
    name: null,
    createdAt: 2021-02-14T20:24:01.209Z,
    updatedAt: 2021-02-14T20:24:01.209Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 71
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [N0KGsF8c3vXDwPilAAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:24:01.190Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 71
}
Ligando o usuário [71] ao socket [72]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 71 AND (("Socket"."id" = 72)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (72)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 71;
Usuário [71] ligado ao socket [72], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 71;
Enviando dados de sessão para o usuário [71]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 71 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 71 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário

> server@1.0.0 start
> nodemon src/index.js

[33m[nodemon] 2.0.4[39m
[33m[nodemon] to restart at any time, enter `rs`[39m
[33m[nodemon] watching path(s): *.*[39m
[33m[nodemon] watching extensions: js,mjs,json[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [SD3Oi0Yhtvpt5o1QAAAA]
Conteúdo de handshake da socket [SD3Oi0Yhtvpt5o1QAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=N0KGsF8c3vXDwPilAAAC; connect.sid=s%3AaXUb9axPc88KG_lSQiLLebZe_KYZnBRT.djxKOOpNy8V61hB8Cod1H1tJu%2B51hrHrl3y0G8kJi1k"
  },
  "time": "Sun Feb 14 2021 17:25:09 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334309867,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYD-lB",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYD-lB"
  }
}
Conteúdo da sessão da socket [SD3Oi0Yhtvpt5o1QAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:25:09.864Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [SD3Oi0Yhtvpt5o1QAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 72,
    updatedAt: 2021-02-14T20:25:09.919Z,
    createdAt: 2021-02-14T20:25:09.919Z,
    name: null
  },
  _previousDataValues: {
    id: 72,
    name: null,
    createdAt: 2021-02-14T20:25:09.919Z,
    updatedAt: 2021-02-14T20:25:09.919Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 72
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [SD3Oi0Yhtvpt5o1QAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:25:09.864Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 72
}
Ligando o usuário [72] ao socket [73]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 72 AND (("Socket"."id" = 73)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (73)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 72;
Usuário [72] ligado ao socket [73], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 72;
Enviando dados de sessão para o usuário [72]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 72 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 72 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [waPsYDzOPcBEa8SWAAAB]
Conteúdo de handshake da socket [waPsYDzOPcBEa8SWAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AgaSHyT1fgFNXidoLj1HHyv8eUXHUy-nC.Y1yUBqYhgNUyTa6GHKt%2FZtDjorjNtfHboVVhQjOjoIA; io=_iTtJZ30-AEbCE_HAAAA"
  },
  "time": "Sun Feb 14 2021 17:25:11 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334311582,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYD_AM",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYD_AM"
  }
}
Conteúdo da sessão da socket [waPsYDzOPcBEa8SWAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:25:11.582Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [waPsYDzOPcBEa8SWAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 73,
    updatedAt: 2021-02-14T20:25:11.595Z,
    createdAt: 2021-02-14T20:25:11.595Z,
    name: null
  },
  _previousDataValues: {
    id: 73,
    name: null,
    createdAt: 2021-02-14T20:25:11.595Z,
    updatedAt: 2021-02-14T20:25:11.595Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 73
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [waPsYDzOPcBEa8SWAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:25:11.582Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 73
}
Ligando o usuário [73] ao socket [74]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 73 AND (("Socket"."id" = 74)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (74)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 73;
Usuário [73] ligado ao socket [74], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 73;
Enviando dados de sessão para o usuário [73]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 73 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 73 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [U_TcBvD_t91cP7v_AAAC]
Conteúdo de handshake da socket [U_TcBvD_t91cP7v_AAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=SD3Oi0Yhtvpt5o1QAAAA; connect.sid=s%3AXly7gr5d91aD-7xox4OEBdcfLjKDeloJ.Apq7MU4QR%2Bdfato%2FY9Opc1eDeGGaO3Ayq%2B3VdjCHKl8"
  },
  "time": "Sun Feb 14 2021 17:25:12 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334312917,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYD_VG",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYD_VG"
  }
}
Conteúdo da sessão da socket [U_TcBvD_t91cP7v_AAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:25:12.917Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [U_TcBvD_t91cP7v_AAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 74,
    updatedAt: 2021-02-14T20:25:12.936Z,
    createdAt: 2021-02-14T20:25:12.936Z,
    name: null
  },
  _previousDataValues: {
    id: 74,
    name: null,
    createdAt: 2021-02-14T20:25:12.936Z,
    updatedAt: 2021-02-14T20:25:12.936Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 74
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [U_TcBvD_t91cP7v_AAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:25:12.917Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 74
}
Ligando o usuário [74] ao socket [75]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 74 AND (("Socket"."id" = 75)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (75)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 74;
Usuário [74] ligado ao socket [75], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 74;
Enviando dados de sessão para o usuário [74]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 74 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 74 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [74] tentando entrar com nome [José] na sala com nome [neo_sala_1]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 74 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 74 ) ON "Room"."id" = "players"."roomId";
Usuário [74] trocou o nome de [null] para [José]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_1]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_1' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 8,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_1',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T20:12:55.698Z,
    updatedAt: 2021-02-14T20:12:55.698Z,
    hostId: 65,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 8,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_1',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T20:12:55.698Z,
    updatedAt: 2021-02-14T20:12:55.698Z,
    hostId: 65,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_1' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 65,
      name: 'Pim',
      createdAt: 2021-02-14T20:12:47.334Z,
      updatedAt: 2021-02-14T20:12:55.679Z
    },
    _previousDataValues: {
      id: 65,
      name: 'Pim',
      createdAt: 2021-02-14T20:12:47.334Z,
      updatedAt: 2021-02-14T20:12:55.679Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_1] que o usuário [74] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 8 AND "RoomPlayer"."userId" = 74);
Tentando adicionar usuário [José] na sala [neo_sala_1]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'José' WHERE "RoomPlayer"."roomId" = 8;
Adicionando usuário [74] à sala [neo_sala_1]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_1
Adicionando usuário [74] para a sala [neo_sala_1] no socket
Enviando mensagem do sistema [José tá na área!] para a sala [neo_sala_1]
Emitindo roomData para os sockets conectados na sala [neo_sala_1]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 8;
emitindo RoomData para todos os sockets do usuário [68]
emitindo roomData para o socket [J6eyn0hhelzwOXLfAAAB] do usuário [68]
emitindo RoomData para todos os sockets do usuário [66]
emitindo roomData para o socket [e68gR5j0eozqzm0QAAAB] do usuário [66]
emitindo RoomData para todos os sockets do usuário [67]
emitindo roomData para o socket [n9mLi3huwud6RB5gAAAA] do usuário [67]
emitindo RoomData para todos os sockets do usuário [74]
emitindo roomData para o socket [U_TcBvD_t91cP7v_AAAC] do usuário [74]
emitindo RoomData para todos os sockets do usuário [65]
Pegando player do usuário [74] na sala [8]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 8 AND "RoomPlayer"."userId" = 74);
Usuário [73] tentando entrar com nome [Pim] na sala com nome [neo_sala_1]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 73 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 73 ) ON "Room"."id" = "players"."roomId";
Usuário [73] trocou o nome de [null] para [Pim]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_1]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_1' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 8,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_1',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T20:12:55.698Z,
    updatedAt: 2021-02-14T20:12:55.698Z,
    hostId: 65,
    players: [
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer]
    ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 8,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_1',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T20:12:55.698Z,
    updatedAt: 2021-02-14T20:12:55.698Z,
    hostId: 65,
    players: [
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer]
    ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_1' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 65,
      name: 'Pim',
      createdAt: 2021-02-14T20:12:47.334Z,
      updatedAt: 2021-02-14T20:12:55.679Z
    },
    _previousDataValues: {
      id: 65,
      name: 'Pim',
      createdAt: 2021-02-14T20:12:47.334Z,
      updatedAt: 2021-02-14T20:12:55.679Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_1] que o usuário [73] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 8 AND "RoomPlayer"."userId" = 73);
Tentando adicionar usuário [Pim] na sala [neo_sala_1]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Pim' WHERE "RoomPlayer"."roomId" = 8;
usuário [Pim] tentando entrar na sala [neo_sala_1] com nome já existente.
Não foi possivel entrar na sala [neo_sala_1]: [esse nome de usuário já existe na sala!]
Usuário [74] com socket [U_TcBvD_t91cP7v_AAAC] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 75
verificando nome da sala do jogador [José] se ele estiver em uma
Enviando mensagem do sistema [Aí, se liga, José caiu.] para a sala [undefined]
Enviando mensagem do sistema [Bora marcar um 10 (5min) e se não voltar a gente continua?] para a sala [undefined]
Emitindo roomData para os sockets conectados na sala [undefined]
node:internal/process/promises:227
          triggerUncaughtException(err, true /* fromPromise */);
          ^

Error: WHERE parameter "roomId" has invalid "undefined" value
    at PostgresQueryGenerator.whereItemQuery (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/dialects/abstract/query-generator.js:2184:13)
    at /home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/dialects/abstract/query-generator.js:2173:25
    at Array.forEach (<anonymous>)
    at PostgresQueryGenerator.whereItemsQuery (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/dialects/abstract/query-generator.js:2171:35)
    at PostgresQueryGenerator.getWhereConditions (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/dialects/abstract/query-generator.js:2583:19)
    at PostgresQueryGenerator.selectQuery (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/dialects/abstract/query-generator.js:1315:28)
    at QueryInterface.select (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/query-interface.js:1127:27)
    at /home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/model.js:1759:34
    at tryCatcher (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/util.js:16:23)
    at Promise._settlePromiseFromHandler (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/promise.js:547:31)
    at Promise._settlePromise (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/promise.js:604:18)
    at Promise._settlePromise0 (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/promise.js:649:10)
    at Promise._settlePromises (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/promise.js:729:18)
    at _drainQueueStep (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/async.js:93:12)
    at _drainQueue (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/async.js:86:9)
    at Async._drainQueues (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/async.js:102:5)
    at Immediate.Async.drainQueues [as _onImmediate] (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/async.js:15:14)
    at processImmediate (node:internal/timers:463:21)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [vCb63SqQx5TO4xbVAAAA]
Conteúdo de handshake da socket [vCb63SqQx5TO4xbVAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3Aj0aFxGN5cujscTZfEJq4YjsUEpRxrWNo.z3wQd0IlFx11e%2BPO%2BqdxAK5VNSEw%2F3r1LpQW5GPb5xY; io=waPsYDzOPcBEa8SWAAAB"
  },
  "time": "Sun Feb 14 2021 17:31:46 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334706510,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYFVat",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYFVat"
  }
}
Conteúdo da sessão da socket [vCb63SqQx5TO4xbVAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:31:46.506Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [vCb63SqQx5TO4xbVAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 75,
    updatedAt: 2021-02-14T20:31:46.568Z,
    createdAt: 2021-02-14T20:31:46.568Z,
    name: null
  },
  _previousDataValues: {
    id: 75,
    name: null,
    createdAt: 2021-02-14T20:31:46.568Z,
    updatedAt: 2021-02-14T20:31:46.568Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 75
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [vCb63SqQx5TO4xbVAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:31:46.506Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 75
}
Ligando o usuário [75] ao socket [76]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 75 AND (("Socket"."id" = 76)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (76)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 75;
Usuário [75] ligado ao socket [76], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 75;
Enviando dados de sessão para o usuário [75]
verificando nome da sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 75 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 75 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [I-BZJGT1eLGyYK4MAAAA]
Conteúdo de handshake da socket [I-BZJGT1eLGyYK4MAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3Ah_j1W0rneSe7i1CouFgz0dGPhsNaXJ7C.RHu3Eea7qIQI9yYOEIgz8C4I8BN%2BtMvR0Oa1SxSmd40; io=vCb63SqQx5TO4xbVAAAA"
  },
  "time": "Sun Feb 14 2021 17:36:09 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613334969258,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYGVkB",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYGVkB"
  }
}
Conteúdo da sessão da socket [I-BZJGT1eLGyYK4MAAAA]: {
  "cookie": {
    "originalMaxAge": 2591999999,
    "expires": "2021-03-16T20:36:09.253Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [I-BZJGT1eLGyYK4MAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 76,
    updatedAt: 2021-02-14T20:36:09.313Z,
    createdAt: 2021-02-14T20:36:09.313Z,
    name: null
  },
  _previousDataValues: {
    id: 76,
    name: null,
    createdAt: 2021-02-14T20:36:09.313Z,
    updatedAt: 2021-02-14T20:36:09.313Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 76
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [I-BZJGT1eLGyYK4MAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:36:09.253Z,
    originalMaxAge: 2591999999,
    httpOnly: true
  },
  userId: 76
}
Ligando o usuário [76] ao socket [77]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 76 AND (("Socket"."id" = 77)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (77)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 76;
Usuário [76] ligado ao socket [77], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 76;
Enviando dados de sessão para o usuário [76]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 76 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 76 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [7AhwveRKz-WvGhCGAAAA]
Conteúdo de handshake da socket [7AhwveRKz-WvGhCGAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3A4-gbECazFWh3AjkRyL0-hqEMj3NJcxg6.gObeyd7CRC7UJ6EXeKZprZjnclno5%2FKOJcPpU7968oo; io=I-BZJGT1eLGyYK4MAAAA"
  },
  "time": "Sun Feb 14 2021 17:38:35 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613335115901,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYH3Xa",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYH3Xa"
  }
}
Conteúdo da sessão da socket [7AhwveRKz-WvGhCGAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:38:35.898Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [7AhwveRKz-WvGhCGAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 77,
    updatedAt: 2021-02-14T20:38:35.953Z,
    createdAt: 2021-02-14T20:38:35.953Z,
    name: null
  },
  _previousDataValues: {
    id: 77,
    name: null,
    createdAt: 2021-02-14T20:38:35.953Z,
    updatedAt: 2021-02-14T20:38:35.953Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 77
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [7AhwveRKz-WvGhCGAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:38:35.898Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 77
}
Ligando o usuário [77] ao socket [78]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 77 AND (("Socket"."id" = 78)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (78)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 77;
Usuário [77] ligado ao socket [78], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 77;
Enviando dados de sessão para o usuário [77]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 77 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 77 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [FCY_Vz1JMmj_IPAMAAAA]
Conteúdo de handshake da socket [FCY_Vz1JMmj_IPAMAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AwJqOvBOmmDfdlXmEKs06Z4QePAvxX1XT.JnyDXq91UiDFndZkITGyNo116TsCERMYaPShKCVqkDw; io=7AhwveRKz-WvGhCGAAAA"
  },
  "time": "Sun Feb 14 2021 17:42:14 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613335334971,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYHv0f",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYHv0f"
  }
}
Conteúdo da sessão da socket [FCY_Vz1JMmj_IPAMAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:42:14.968Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [FCY_Vz1JMmj_IPAMAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 78,
    updatedAt: 2021-02-14T20:42:15.028Z,
    createdAt: 2021-02-14T20:42:15.028Z,
    name: null
  },
  _previousDataValues: {
    id: 78,
    name: null,
    createdAt: 2021-02-14T20:42:15.028Z,
    updatedAt: 2021-02-14T20:42:15.028Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 78
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [FCY_Vz1JMmj_IPAMAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:42:14.968Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 78
}
Ligando o usuário [78] ao socket [79]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 78 AND (("Socket"."id" = 79)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (79)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 78;
Usuário [78] ligado ao socket [79], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 78;
Enviando dados de sessão para o usuário [78]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 78 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 78 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [4cd16g3kbxjL3YcwAAAA]
Conteúdo de handshake da socket [4cd16g3kbxjL3YcwAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AjY6M1MQ-IBuC5TwD94LTtU0JoRs4rY0d.M5aDrHZASp8b05ojzc5wSXrj0JxRBsaqPoQcuV4HQIM; io=FCY_Vz1JMmj_IPAMAAAA"
  },
  "time": "Sun Feb 14 2021 17:48:42 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613335722950,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYJNkn",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYJNkn"
  }
}
Conteúdo da sessão da socket [4cd16g3kbxjL3YcwAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:48:42.947Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [4cd16g3kbxjL3YcwAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 79,
    updatedAt: 2021-02-14T20:48:43.023Z,
    createdAt: 2021-02-14T20:48:43.023Z,
    name: null
  },
  _previousDataValues: {
    id: 79,
    name: null,
    createdAt: 2021-02-14T20:48:43.023Z,
    updatedAt: 2021-02-14T20:48:43.023Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 79
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [4cd16g3kbxjL3YcwAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:48:42.947Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 79
}
Ligando o usuário [79] ao socket [80]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 79 AND (("Socket"."id" = 80)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (80)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 79;
Usuário [79] ligado ao socket [80], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 79;
Enviando dados de sessão para o usuário [79]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 79 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 79 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [pHmmB46wRrHgE3O-AAAA]
Conteúdo de handshake da socket [pHmmB46wRrHgE3O-AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3Acsp9x1uuP5JbhCIkaezRA6948wf4FcKn.aOTaohN5qovP34t8H2Nk%2F4DIdvID%2FkkiP6YebCTvA5o; io=4cd16g3kbxjL3YcwAAAA"
  },
  "time": "Sun Feb 14 2021 17:55:59 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336159237,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYL2FR",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYL2FR"
  }
}
Conteúdo da sessão da socket [pHmmB46wRrHgE3O-AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:55:59.233Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [pHmmB46wRrHgE3O-AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 80,
    updatedAt: 2021-02-14T20:55:59.292Z,
    createdAt: 2021-02-14T20:55:59.292Z,
    name: null
  },
  _previousDataValues: {
    id: 80,
    name: null,
    createdAt: 2021-02-14T20:55:59.292Z,
    updatedAt: 2021-02-14T20:55:59.292Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 80
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [pHmmB46wRrHgE3O-AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:55:59.233Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 80
}
Ligando o usuário [80] ao socket [81]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 80 AND (("Socket"."id" = 81)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (81)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 80;
Usuário [80] ligado ao socket [81], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 80;
Enviando dados de sessão para o usuário [80]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 80 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 80 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [dSxUffE5YYwMYXgxAAAA]
Conteúdo de handshake da socket [dSxUffE5YYwMYXgxAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AEzCdsYbFDcfZkBWbnTGM0lj1Keb4TMMj.eI55Szx%2Fk249n84SCMIW7uEcrEk7ePtjkUsOzUcQF44; io=pHmmB46wRrHgE3O-AAAA"
  },
  "time": "Sun Feb 14 2021 17:56:19 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336179479,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYL7Bw",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYL7Bw"
  }
}
Conteúdo da sessão da socket [dSxUffE5YYwMYXgxAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T20:56:19.475Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [dSxUffE5YYwMYXgxAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 81,
    updatedAt: 2021-02-14T20:56:19.533Z,
    createdAt: 2021-02-14T20:56:19.533Z,
    name: null
  },
  _previousDataValues: {
    id: 81,
    name: null,
    createdAt: 2021-02-14T20:56:19.533Z,
    updatedAt: 2021-02-14T20:56:19.533Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 81
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [dSxUffE5YYwMYXgxAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T20:56:19.475Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 81
}
Ligando o usuário [81] ao socket [82]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 81 AND (("Socket"."id" = 82)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (82)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 81;
Usuário [81] ligado ao socket [82], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 81;
Enviando dados de sessão para o usuário [81]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 81 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 81 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [cugHqh1cOuy0XVxXAAAA]
Conteúdo de handshake da socket [cugHqh1cOuy0XVxXAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3Ax_0PZQH1oulVN0Tay1Zen6TpCvwPiZeE.BHOnkBvzbzrcKPxw8bIQ7w8G3Ocyau%2F1TaNmtsRB37s; io=dSxUffE5YYwMYXgxAAAA"
  },
  "time": "Sun Feb 14 2021 18:00:16 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336416325,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYM10Q",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYM10Q"
  }
}
Conteúdo da sessão da socket [cugHqh1cOuy0XVxXAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:00:16.320Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [cugHqh1cOuy0XVxXAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 82,
    updatedAt: 2021-02-14T21:00:16.383Z,
    createdAt: 2021-02-14T21:00:16.383Z,
    name: null
  },
  _previousDataValues: {
    id: 82,
    name: null,
    createdAt: 2021-02-14T21:00:16.383Z,
    updatedAt: 2021-02-14T21:00:16.383Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 82
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [cugHqh1cOuy0XVxXAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:00:16.320Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 82
}
Ligando o usuário [82] ao socket [83]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 82 AND (("Socket"."id" = 83)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (83)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 82;
Usuário [82] ligado ao socket [83], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 82;
Enviando dados de sessão para o usuário [82]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 82 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 82 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [Xehv_JmeC5u13zT-AAAA]
Conteúdo de handshake da socket [Xehv_JmeC5u13zT-AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3A8Y-LVOou8wNzm4xP8jTKjpQPOokUtlNm.e9fV6m7wGjS2H3vlantPlgSOhv%2BXWgsOBIxXzvodwaE; io=cugHqh1cOuy0XVxXAAAA"
  },
  "time": "Sun Feb 14 2021 18:01:27 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336487801,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYMITQ",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYMITQ"
  }
}
Conteúdo da sessão da socket [Xehv_JmeC5u13zT-AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:01:27.797Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [Xehv_JmeC5u13zT-AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 83,
    updatedAt: 2021-02-14T21:01:27.857Z,
    createdAt: 2021-02-14T21:01:27.857Z,
    name: null
  },
  _previousDataValues: {
    id: 83,
    name: null,
    createdAt: 2021-02-14T21:01:27.857Z,
    updatedAt: 2021-02-14T21:01:27.857Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 83
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [Xehv_JmeC5u13zT-AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:01:27.797Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 83
}
Ligando o usuário [83] ao socket [84]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 83 AND (("Socket"."id" = 84)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (84)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 83;
Usuário [83] ligado ao socket [84], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 83;
Enviando dados de sessão para o usuário [83]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 83 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 83 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [CuykiDbmW0KZ_o44AAAA]
Conteúdo de handshake da socket [CuykiDbmW0KZ_o44AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AcJp_UbS2FHKcfyWFg5Lz1D1I3o2rgVlk.g6lutBIv56lukydCcDj32eqQoVomupagRzhoRudh5ww; io=Xehv_JmeC5u13zT-AAAA"
  },
  "time": "Sun Feb 14 2021 18:02:04 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336524212,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYMRMI",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYMRMI"
  }
}
Conteúdo da sessão da socket [CuykiDbmW0KZ_o44AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:02:04.208Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [CuykiDbmW0KZ_o44AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 84,
    updatedAt: 2021-02-14T21:02:04.265Z,
    createdAt: 2021-02-14T21:02:04.265Z,
    name: null
  },
  _previousDataValues: {
    id: 84,
    name: null,
    createdAt: 2021-02-14T21:02:04.265Z,
    updatedAt: 2021-02-14T21:02:04.265Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 84
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [CuykiDbmW0KZ_o44AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:02:04.208Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 84
}
Ligando o usuário [84] ao socket [85]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 84 AND (("Socket"."id" = 85)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (85)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 84;
Usuário [84] ligado ao socket [85], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 84;
Enviando dados de sessão para o usuário [84]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 84 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 84 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [VZDsGev3bqHGZK5eAAAA]
Conteúdo de handshake da socket [VZDsGev3bqHGZK5eAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AFAG1vMT_xQ039Divp7dmMMiARd-OAl2K.4%2B3heedGd7lZVYScTzmUP4n78dZzoU9wFfbwE7Orq20; io=CuykiDbmW0KZ_o44AAAA"
  },
  "time": "Sun Feb 14 2021 18:03:40 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336620463,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYMosK",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYMosK"
  }
}
Conteúdo da sessão da socket [VZDsGev3bqHGZK5eAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:03:40.459Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [VZDsGev3bqHGZK5eAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 85,
    updatedAt: 2021-02-14T21:03:40.521Z,
    createdAt: 2021-02-14T21:03:40.521Z,
    name: null
  },
  _previousDataValues: {
    id: 85,
    name: null,
    createdAt: 2021-02-14T21:03:40.521Z,
    updatedAt: 2021-02-14T21:03:40.521Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 85
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [VZDsGev3bqHGZK5eAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:03:40.459Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 85
}
Ligando o usuário [85] ao socket [86]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 85 AND (("Socket"."id" = 86)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (86)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 85;
Usuário [85] ligado ao socket [86], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 85;
Enviando dados de sessão para o usuário [85]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 85 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 85 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [UB-G1N5c29Mmae0xAAAA]
Conteúdo de handshake da socket [UB-G1N5c29Mmae0xAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AKPW2k1xCzrLp5fNnz0VnOoCZNU4HAekL.1mY1J7ApcpXt2lOPMm8ZW5Jnjh%2BgndT2mBNWhv7%2Bmc0; io=VZDsGev3bqHGZK5eAAAA"
  },
  "time": "Sun Feb 14 2021 18:04:14 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336654961,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYMxHB",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYMxHB"
  }
}
Conteúdo da sessão da socket [UB-G1N5c29Mmae0xAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:04:14.957Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [UB-G1N5c29Mmae0xAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 86,
    updatedAt: 2021-02-14T21:04:15.014Z,
    createdAt: 2021-02-14T21:04:15.014Z,
    name: null
  },
  _previousDataValues: {
    id: 86,
    name: null,
    createdAt: 2021-02-14T21:04:15.014Z,
    updatedAt: 2021-02-14T21:04:15.014Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 86
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [UB-G1N5c29Mmae0xAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:04:14.957Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 86
}
Ligando o usuário [86] ao socket [87]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 86 AND (("Socket"."id" = 87)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (87)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 86;
Usuário [86] ligado ao socket [87], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 86;
Enviando dados de sessão para o usuário [86]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 86 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 86 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [YPXWeFzRsaVjyGMPAAAA]
Conteúdo de handshake da socket [YPXWeFzRsaVjyGMPAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AUBe4Jr1pGFjlqtJ4SXYKOpC5VQEkguOX.wRIGblraffhv1j%2FvpEGqNPgBoR3GeRowBsOZmyYa%2B20; io=UB-G1N5c29Mmae0xAAAA"
  },
  "time": "Sun Feb 14 2021 18:04:26 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336666742,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYM-9f",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYM-9f"
  }
}
Conteúdo da sessão da socket [YPXWeFzRsaVjyGMPAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:04:26.740Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [YPXWeFzRsaVjyGMPAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 87,
    updatedAt: 2021-02-14T21:04:26.797Z,
    createdAt: 2021-02-14T21:04:26.797Z,
    name: null
  },
  _previousDataValues: {
    id: 87,
    name: null,
    createdAt: 2021-02-14T21:04:26.797Z,
    updatedAt: 2021-02-14T21:04:26.797Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 87
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [YPXWeFzRsaVjyGMPAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:04:26.740Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 87
}
Ligando o usuário [87] ao socket [88]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 87 AND (("Socket"."id" = 88)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (88)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 87;
Usuário [87] ligado ao socket [88], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 87;
Enviando dados de sessão para o usuário [87]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 87 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 87 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [qepcvzml7mnPQpckAAAA]
Conteúdo de handshake da socket [qepcvzml7mnPQpckAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3A2xoOAB0finvac0glnAk1Y-B-txXKNss1.ZUnEVlKuZUAuiXfgOyRiPNqtdZNfuH73%2BWKYp1Blifo; io=YPXWeFzRsaVjyGMPAAAA"
  },
  "time": "Sun Feb 14 2021 18:05:12 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336712237,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYN9GY",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYN9GY"
  }
}
Conteúdo da sessão da socket [qepcvzml7mnPQpckAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:05:12.235Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [qepcvzml7mnPQpckAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 88,
    updatedAt: 2021-02-14T21:05:12.284Z,
    createdAt: 2021-02-14T21:05:12.284Z,
    name: null
  },
  _previousDataValues: {
    id: 88,
    name: null,
    createdAt: 2021-02-14T21:05:12.284Z,
    updatedAt: 2021-02-14T21:05:12.284Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 88
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [qepcvzml7mnPQpckAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:05:12.235Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 88
}
Ligando o usuário [88] ao socket [89]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 88 AND (("Socket"."id" = 89)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (89)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 88;
Usuário [88] ligado ao socket [89], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 88;
Enviando dados de sessão para o usuário [88]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 88 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 88 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [0rHhKd7MV040QNULAAAA]
Conteúdo de handshake da socket [0rHhKd7MV040QNULAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AoW7C_Hgjc2u19wVwZ8VqQJqniRQ6qeX2.tZ6v%2B1SC41%2BsGhrBGB2BJoOS9L3C1BTOwXEBisQbYsI; io=qepcvzml7mnPQpckAAAA"
  },
  "time": "Sun Feb 14 2021 18:05:17 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336717369,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYNAWR",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYNAWR"
  }
}
Conteúdo da sessão da socket [0rHhKd7MV040QNULAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:05:17.365Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [0rHhKd7MV040QNULAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 89,
    updatedAt: 2021-02-14T21:05:17.428Z,
    createdAt: 2021-02-14T21:05:17.428Z,
    name: null
  },
  _previousDataValues: {
    id: 89,
    name: null,
    createdAt: 2021-02-14T21:05:17.428Z,
    updatedAt: 2021-02-14T21:05:17.428Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 89
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [0rHhKd7MV040QNULAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:05:17.365Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 89
}
Ligando o usuário [89] ao socket [90]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 89 AND (("Socket"."id" = 90)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (90)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 89;
Usuário [89] ligado ao socket [90], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 89;
Enviando dados de sessão para o usuário [89]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 89 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 89 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [2itr_g6_1YCsQLWJAAAA]
Conteúdo de handshake da socket [2itr_g6_1YCsQLWJAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_1",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AVdc_gfYH3sO5yIdqvTjvfLyg-QFA0VBy.7QiJzCRaC2%2FDqAvcPmygv8W68%2FGyoOr%2FagUnmRVncvs; io=0rHhKd7MV040QNULAAAA"
  },
  "time": "Sun Feb 14 2021 18:06:38 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336798601,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYNULc",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYNULc"
  }
}
Conteúdo da sessão da socket [2itr_g6_1YCsQLWJAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:06:38.596Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [2itr_g6_1YCsQLWJAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 90,
    updatedAt: 2021-02-14T21:06:38.656Z,
    createdAt: 2021-02-14T21:06:38.656Z,
    name: null
  },
  _previousDataValues: {
    id: 90,
    name: null,
    createdAt: 2021-02-14T21:06:38.656Z,
    updatedAt: 2021-02-14T21:06:38.656Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 90
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [2itr_g6_1YCsQLWJAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:06:38.596Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 90
}
Ligando o usuário [90] ao socket [91]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 90 AND (("Socket"."id" = 91)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (91)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 90;
Usuário [90] ligado ao socket [91], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 90;
Enviando dados de sessão para o usuário [90]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 90 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 90 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [90] tentando entrar com nome [Pim] na sala com nome [neo_sala_2]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 90 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 90 ) ON "Room"."id" = "players"."roomId";
Usuário [90] trocou o nome de [null] para [Pim]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
null
A sala que o usuário tentou entrar [neo_sala_2] não existe ainda, vamos criar uma para ele
Criando uma sala com nome [neo_sala_2] para o hostPlayer [Pim]
Buscando uma sala com nome [neo_sala_2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Procurando uma sala existente [Sala disponível]
Executing (default): INSERT INTO "rooms" ("id","state","name","turn","currentPlayerIndex","prompt","selectedCardCount","victory","votingCardsTurn","winner","minimumPlayersToStart","minimumCardsToStart","selectedDecksIds","deck","morto","results","createdAt","updatedAt","hostId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18) RETURNING *;
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
[]
Sala criada com nome [neo_sala_2] e host player [Pim]
Buscando uma sala com nome [neo_sala_2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Sala [neo_sala_2] criada para o usuário [90]
Sala atual é: neo_sala_2
Adicionando usuário [90] para a sala [neo_sala_2] no socket
Enviando mensagem do sistema [Pim tá na área!] para a sala [neo_sala_2]
Emitindo roomData para os sockets conectados na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 9;
emitindo RoomData para todos os sockets do usuário [90]
emitindo roomData para o socket [2itr_g6_1YCsQLWJAAAA] do usuário [90]
Pegando player do usuário [90] na sala [9]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 90);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [QYR2Vq7ehqEitk_zAAAB]
Conteúdo de handshake da socket [QYR2Vq7ehqEitk_zAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/"
  },
  "time": "Sun Feb 14 2021 18:06:59 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336819241,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYNZOc",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYNZOc"
  }
}
Conteúdo da sessão da socket [QYR2Vq7ehqEitk_zAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:06:59.241Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [QYR2Vq7ehqEitk_zAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 91,
    updatedAt: 2021-02-14T21:06:59.247Z,
    createdAt: 2021-02-14T21:06:59.247Z,
    name: null
  },
  _previousDataValues: {
    id: 91,
    name: null,
    createdAt: 2021-02-14T21:06:59.247Z,
    updatedAt: 2021-02-14T21:06:59.247Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 91
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [QYR2Vq7ehqEitk_zAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:06:59.241Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 91
}
Ligando o usuário [91] ao socket [92]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 91 AND (("Socket"."id" = 92)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (92)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 91;
Usuário [91] ligado ao socket [92], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 91;
Enviando dados de sessão para o usuário [91]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 91 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 91 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [91] tentando entrar com nome [Vitu] na sala com nome [neo_sala_2]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 91 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 91 ) ON "Room"."id" = "players"."roomId";
Usuário [91] trocou o nome de [null] para [Vitu]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_2' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _previousDataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_2] que o usuário [91] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 91);
Tentando adicionar usuário [Vitu] na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Vitu' WHERE "RoomPlayer"."roomId" = 9;
Adicionando usuário [91] à sala [neo_sala_2]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_2
Adicionando usuário [91] para a sala [neo_sala_2] no socket
Enviando mensagem do sistema [Vitu tá na área!] para a sala [neo_sala_2]
Emitindo roomData para os sockets conectados na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 9;
emitindo RoomData para todos os sockets do usuário [90]
emitindo roomData para o socket [2itr_g6_1YCsQLWJAAAA] do usuário [90]
emitindo RoomData para todos os sockets do usuário [91]
emitindo roomData para o socket [QYR2Vq7ehqEitk_zAAAB] do usuário [91]
Pegando player do usuário [91] na sala [9]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 91);
Usuário [91] com socket [QYR2Vq7ehqEitk_zAAAB] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 92
retornando a sala do jogador [Vitu] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 91 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 91 ) ON "Room"."id" = "players"."roomId";
CONDIÇÃO AINDA NÃO IMPLEMENTADA!
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [ANdkDR8K_wr30IJlAAAC]
Conteúdo de handshake da socket [ANdkDR8K_wr30IJlAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=QYR2Vq7ehqEitk_zAAAB; connect.sid=s%3AhpGzgmNRRiI6z_UbCNo702VFMzHFRyGl.SkPFp3fT3%2FahwcK2owHzbcaO9MNiHaLuYgaLNXuUpOg"
  },
  "time": "Sun Feb 14 2021 18:07:16 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336836829,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYNdhQ",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYNdhQ"
  }
}
Conteúdo da sessão da socket [ANdkDR8K_wr30IJlAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:07:16.828Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 91
}
Executing (default): SELECT "id", "name", "createdAt", "updatedAt" FROM "users" AS "User" WHERE "User"."id" = 91;
Detectei o usuário com id [91] para a socket com id [ANdkDR8K_wr30IJlAAAC]
retornando a sala do jogador [Vitu] se ele estiver em uma
O usuário [91] já está na sala [undefined], vou mandar os dados da sala para ele!
adicionando socket.id [ANdkDR8K_wr30IJlAAAC] na socketRoom [undefined]
Emitindo roomData para os sockets conectados na sala [undefined]
Ligando o usuário [91] ao socket [93]
node:internal/process/promises:227
          triggerUncaughtException(err, true /* fromPromise */);
          ^

Error: WHERE parameter "roomId" has invalid "undefined" value
    at PostgresQueryGenerator.whereItemQuery (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/dialects/abstract/query-generator.js:2184:13)
    at /home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/dialects/abstract/query-generator.js:2173:25
    at Array.forEach (<anonymous>)
    at PostgresQueryGenerator.whereItemsQuery (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/dialects/abstract/query-generator.js:2171:35)
    at PostgresQueryGenerator.getWhereConditions (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/dialects/abstract/query-generator.js:2583:19)
    at PostgresQueryGenerator.selectQuery (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/dialects/abstract/query-generator.js:1315:28)
    at QueryInterface.select (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/query-interface.js:1127:27)
    at /home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/sequelize/lib/model.js:1759:34
    at tryCatcher (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/util.js:16:23)
    at Promise._settlePromiseFromHandler (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/promise.js:547:31)
    at Promise._settlePromise (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/promise.js:604:18)
    at Promise._settlePromise0 (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/promise.js:649:10)
    at Promise._settlePromises (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/promise.js:729:18)
    at _drainQueueStep (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/async.js:93:12)
    at _drainQueue (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/async.js:86:9)
    at Async._drainQueues (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/async.js:102:5)
    at Immediate.Async.drainQueues [as _onImmediate] (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/bluebird/js/release/async.js:15:14)
    at processImmediate (node:internal/timers:463:21)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [YWvVG_YxDLqu2kCVAAAA]
Conteúdo de handshake da socket [YWvVG_YxDLqu2kCVAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=ANdkDR8K_wr30IJlAAAC; connect.sid=s%3AhpGzgmNRRiI6z_UbCNo702VFMzHFRyGl.SkPFp3fT3%2FahwcK2owHzbcaO9MNiHaLuYgaLNXuUpOg"
  },
  "time": "Sun Feb 14 2021 18:09:50 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336990323,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYOD9S",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYOD9S"
  }
}
Conteúdo da sessão da socket [YWvVG_YxDLqu2kCVAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:09:50.319Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [YWvVG_YxDLqu2kCVAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 92,
    updatedAt: 2021-02-14T21:09:50.379Z,
    createdAt: 2021-02-14T21:09:50.379Z,
    name: null
  },
  _previousDataValues: {
    id: 92,
    name: null,
    createdAt: 2021-02-14T21:09:50.379Z,
    updatedAt: 2021-02-14T21:09:50.379Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 92
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [YWvVG_YxDLqu2kCVAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:09:50.319Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 92
}
Ligando o usuário [92] ao socket [94]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 92 AND (("Socket"."id" = 94)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (94)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 92;
Usuário [92] ligado ao socket [94], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 92;
Enviando dados de sessão para o usuário [92]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 92 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 92 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [zTnZ3xUKqcEhSahCAAAB]
Conteúdo de handshake da socket [zTnZ3xUKqcEhSahCAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/neo_sala_2",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AOdh_P_y_OQD-IBldwrjuu3BhKLww0ZYK.o%2FU9tEv8q1VJb33MpOX2KN%2FjDgYIxlT5sMyElyyDAQw; io=2itr_g6_1YCsQLWJAAAA"
  },
  "time": "Sun Feb 14 2021 18:09:50 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336990701,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYODFd",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYODFd"
  }
}
Conteúdo da sessão da socket [zTnZ3xUKqcEhSahCAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:09:50.700Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [zTnZ3xUKqcEhSahCAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 93,
    updatedAt: 2021-02-14T21:09:50.716Z,
    createdAt: 2021-02-14T21:09:50.716Z,
    name: null
  },
  _previousDataValues: {
    id: 93,
    name: null,
    createdAt: 2021-02-14T21:09:50.716Z,
    updatedAt: 2021-02-14T21:09:50.716Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 93
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [zTnZ3xUKqcEhSahCAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:09:50.700Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 93
}
Ligando o usuário [93] ao socket [95]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 93 AND (("Socket"."id" = 95)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (95)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 93;
Usuário [93] ligado ao socket [95], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 93;
Enviando dados de sessão para o usuário [93]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 93 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 93 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [tpEDumJZsAqXDWZZAAAA]
Conteúdo de handshake da socket [tpEDumJZsAqXDWZZAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=YWvVG_YxDLqu2kCVAAAA; connect.sid=s%3Asb8C_vfYGCv-mIRDr3UP_QAZbXlQrexq.NP4fJYxWXKJi76BFRr1isSiGTN9DVTM2tgniy9H%2B0wQ"
  },
  "time": "Sun Feb 14 2021 18:09:52 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336992607,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYODj3",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYODj3"
  }
}
Conteúdo da sessão da socket [tpEDumJZsAqXDWZZAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:09:52.603Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [tpEDumJZsAqXDWZZAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 94,
    updatedAt: 2021-02-14T21:09:52.662Z,
    createdAt: 2021-02-14T21:09:52.662Z,
    name: null
  },
  _previousDataValues: {
    id: 94,
    name: null,
    createdAt: 2021-02-14T21:09:52.662Z,
    updatedAt: 2021-02-14T21:09:52.662Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 94
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [tpEDumJZsAqXDWZZAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:09:52.603Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 94
}
Ligando o usuário [94] ao socket [96]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 94 AND (("Socket"."id" = 96)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (96)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 94;
Usuário [94] ligado ao socket [96], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 94;
Enviando dados de sessão para o usuário [94]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 94 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 94 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [yN1Jxe9YkGqYauVlAAAB]
Conteúdo de handshake da socket [yN1Jxe9YkGqYauVlAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_2",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3ABYRz5PPJETB3BbkNLAufVeGDv0t1STrc.i1GL03rp6QwzSgH%2BJScl83zxp8%2FIAuki1qPiPg7d0C0; io=zTnZ3xUKqcEhSahCAAAB"
  },
  "time": "Sun Feb 14 2021 18:09:52 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613336992995,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYODpS",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYODpS"
  }
}
Conteúdo da sessão da socket [yN1Jxe9YkGqYauVlAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:09:52.994Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [yN1Jxe9YkGqYauVlAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 95,
    updatedAt: 2021-02-14T21:09:53.015Z,
    createdAt: 2021-02-14T21:09:53.015Z,
    name: null
  },
  _previousDataValues: {
    id: 95,
    name: null,
    createdAt: 2021-02-14T21:09:53.015Z,
    updatedAt: 2021-02-14T21:09:53.015Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 95
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [yN1Jxe9YkGqYauVlAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:09:52.994Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 95
}
Ligando o usuário [95] ao socket [97]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 95 AND (("Socket"."id" = 97)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (97)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 95;
Usuário [95] ligado ao socket [97], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 95;
Enviando dados de sessão para o usuário [95]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 95 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 95 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [94] tentando entrar com nome [Flavip] na sala com nome [neo_sala_2]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 94 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 94 ) ON "Room"."id" = "players"."roomId";
Usuário [94] trocou o nome de [null] para [Flavip]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [ [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [ [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_2' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _previousDataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_2] que o usuário [94] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 94);
Tentando adicionar usuário [Flavip] na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Flavip' WHERE "RoomPlayer"."roomId" = 9;
Adicionando usuário [94] à sala [neo_sala_2]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_2
Adicionando usuário [94] para a sala [neo_sala_2] no socket
Enviando mensagem do sistema [Flavip tá na área!] para a sala [neo_sala_2]
Emitindo roomData para os sockets conectados na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 9;
emitindo RoomData para todos os sockets do usuário [90]
emitindo roomData para o socket [2itr_g6_1YCsQLWJAAAA] do usuário [90]
emitindo RoomData para todos os sockets do usuário [94]
emitindo roomData para o socket [tpEDumJZsAqXDWZZAAAA] do usuário [94]
emitindo RoomData para todos os sockets do usuário [91]
Pegando player do usuário [94] na sala [9]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 94);
Usuário [94] com socket [tpEDumJZsAqXDWZZAAAA] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 96
retornando a sala do jogador [Flavip] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 94 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 94 ) ON "Room"."id" = "players"."roomId";
CONDIÇÃO AINDA NÃO IMPLEMENTADA!
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [_LatWm55I6wN7UIAAAAC]
Conteúdo de handshake da socket [_LatWm55I6wN7UIAAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=tpEDumJZsAqXDWZZAAAA; connect.sid=s%3AgtHLgCbjUnMRp-ry2A-_fDUSusJ9YyLr.Prt0TYjxrCSc4%2BUI8qsd8%2BhamtEY558jSfkoXUnwNX4"
  },
  "time": "Sun Feb 14 2021 18:10:03 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337003986,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYOGVG",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYOGVG"
  }
}
Conteúdo da sessão da socket [_LatWm55I6wN7UIAAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:10:03.986Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [_LatWm55I6wN7UIAAAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 96,
    updatedAt: 2021-02-14T21:10:04.001Z,
    createdAt: 2021-02-14T21:10:04.001Z,
    name: null
  },
  _previousDataValues: {
    id: 96,
    name: null,
    createdAt: 2021-02-14T21:10:04.001Z,
    updatedAt: 2021-02-14T21:10:04.001Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 96
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [_LatWm55I6wN7UIAAAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:10:03.986Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 96
}
Ligando o usuário [96] ao socket [98]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 96 AND (("Socket"."id" = 98)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (98)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 96;
Usuário [96] ligado ao socket [98], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 96;
Enviando dados de sessão para o usuário [96]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 96 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 96 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [96] tentando entrar com nome [Flavip] na sala com nome [neo_sala_2]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 96 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 96 ) ON "Room"."id" = "players"."roomId";
Usuário [96] trocou o nome de [null] para [Flavip]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_2' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _previousDataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_2] que o usuário [96] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 96);
Tentando adicionar usuário [Flavip] na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Flavip' WHERE "RoomPlayer"."roomId" = 9;
usuário [Flavip] tentando entrar na sala [neo_sala_2] com nome já existente.
Não foi possivel entrar na sala [neo_sala_2]: [esse nome de usuário já existe na sala!]
Usuário [96] tentando entrar com nome [Flavio] na sala com nome [neo_sala_2]
retornando a sala do jogador [Flavip] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 96 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 96 ) ON "Room"."id" = "players"."roomId";
Usuário [96] trocou o nome de [Flavip] para [Flavio]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_2' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _previousDataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_2] que o usuário [96] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 96);
Tentando adicionar usuário [Flavio] na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Flavio' WHERE "RoomPlayer"."roomId" = 9;
Adicionando usuário [96] à sala [neo_sala_2]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_2
Adicionando usuário [96] para a sala [neo_sala_2] no socket
Enviando mensagem do sistema [Flavio tá na área!] para a sala [neo_sala_2]
Emitindo roomData para os sockets conectados na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 9;
emitindo RoomData para todos os sockets do usuário [90]
emitindo roomData para o socket [2itr_g6_1YCsQLWJAAAA] do usuário [90]
emitindo RoomData para todos os sockets do usuário [96]
emitindo roomData para o socket [_LatWm55I6wN7UIAAAAC] do usuário [96]
emitindo RoomData para todos os sockets do usuário [91]
emitindo RoomData para todos os sockets do usuário [94]
Pegando player do usuário [96] na sala [9]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 96);
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [4J5VNxBsJ6KMSOI3AAAA]
Conteúdo de handshake da socket [4J5VNxBsJ6KMSOI3AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_2",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AQDC_HHQgOKnh3kvf7-C2N0HdBIIebBPi.0D%2B84Lhs7XfTjd763st%2B8c%2FXbx8mYEeordQ%2F7%2BCkNnk; io=yN1Jxe9YkGqYauVlAAAB"
  },
  "time": "Sun Feb 14 2021 18:12:49 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337169287,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYOurX",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYOurX"
  }
}
Conteúdo da sessão da socket [4J5VNxBsJ6KMSOI3AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:12:49.284Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [4J5VNxBsJ6KMSOI3AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 97,
    updatedAt: 2021-02-14T21:12:49.342Z,
    createdAt: 2021-02-14T21:12:49.342Z,
    name: null
  },
  _previousDataValues: {
    id: 97,
    name: null,
    createdAt: 2021-02-14T21:12:49.342Z,
    updatedAt: 2021-02-14T21:12:49.342Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 97
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [4J5VNxBsJ6KMSOI3AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:12:49.284Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 97
}
Ligando o usuário [97] ao socket [99]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 97 AND (("Socket"."id" = 99)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (99)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 97;
Usuário [97] ligado ao socket [99], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 97;
Enviando dados de sessão para o usuário [97]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 97 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 97 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [8r4Mni0OLYdzq65lAAAB]
Conteúdo de handshake da socket [8r4Mni0OLYdzq65lAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=_LatWm55I6wN7UIAAAAC; connect.sid=s%3AgtHLgCbjUnMRp-ry2A-_fDUSusJ9YyLr.Prt0TYjxrCSc4%2BUI8qsd8%2BhamtEY558jSfkoXUnwNX4"
  },
  "time": "Sun Feb 14 2021 18:12:50 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337170142,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYOv3Q",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYOv3Q"
  }
}
Conteúdo da sessão da socket [8r4Mni0OLYdzq65lAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:12:50.142Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [8r4Mni0OLYdzq65lAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 98,
    updatedAt: 2021-02-14T21:12:50.158Z,
    createdAt: 2021-02-14T21:12:50.158Z,
    name: null
  },
  _previousDataValues: {
    id: 98,
    name: null,
    createdAt: 2021-02-14T21:12:50.158Z,
    updatedAt: 2021-02-14T21:12:50.158Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 98
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [8r4Mni0OLYdzq65lAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:12:50.142Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 98
}
Ligando o usuário [98] ao socket [100]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 98 AND (("Socket"."id" = 100)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (100)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 98;
Usuário [98] ligado ao socket [100], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 98;
Enviando dados de sessão para o usuário [98]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 98 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 98 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [98] tentando entrar com nome [gajo] na sala com nome [neo_sala_2]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 98 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 98 ) ON "Room"."id" = "players"."roomId";
Usuário [98] trocou o nome de [null] para [gajo]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_2' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _previousDataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_2] que o usuário [98] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 98);
Tentando adicionar usuário [gajo] na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'gajo' WHERE "RoomPlayer"."roomId" = 9;
Adicionando usuário [98] à sala [neo_sala_2]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_2
Adicionando usuário [98] para a sala [neo_sala_2] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 9;
Enviando mensagem do sistema [gajo tá na área!] para a sala [neo_sala_2]
Emitindo roomData para os sockets conectados na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 9;
emitindo RoomData para todos os sockets do usuário [90]
emitindo roomData para o socket [2itr_g6_1YCsQLWJAAAA] do usuário [90]
emitindo RoomData para todos os sockets do usuário [96]
emitindo roomData para o socket [_LatWm55I6wN7UIAAAAC] do usuário [96]
emitindo RoomData para todos os sockets do usuário [98]
emitindo roomData para o socket [8r4Mni0OLYdzq65lAAAB] do usuário [98]
emitindo RoomData para todos os sockets do usuário [91]
emitindo RoomData para todos os sockets do usuário [94]
Pegando player do usuário [98] na sala [9]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 98);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [3rwx0vw_pT6rdr0_AAAC]
Conteúdo de handshake da socket [3rwx0vw_pT6rdr0_AAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=8r4Mni0OLYdzq65lAAAB; connect.sid=s%3AjrcgBgG3MTDFm_UTfPBawga4QYbOlME-.vKjGMIwdEFZ2wg4htcwqMgHHnH8lGeMbohe1Mzk56vQ"
  },
  "time": "Sun Feb 14 2021 18:13:05 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337185687,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYOysL",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYOysL"
  }
}
Conteúdo da sessão da socket [3rwx0vw_pT6rdr0_AAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:13:05.687Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [3rwx0vw_pT6rdr0_AAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 99,
    updatedAt: 2021-02-14T21:13:05.694Z,
    createdAt: 2021-02-14T21:13:05.694Z,
    name: null
  },
  _previousDataValues: {
    id: 99,
    name: null,
    createdAt: 2021-02-14T21:13:05.694Z,
    updatedAt: 2021-02-14T21:13:05.694Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 99
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [3rwx0vw_pT6rdr0_AAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:13:05.687Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 99
}
Ligando o usuário [99] ao socket [101]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 99 AND (("Socket"."id" = 101)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (101)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 99;
Usuário [99] ligado ao socket [101], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 99;
Enviando dados de sessão para o usuário [99]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 99 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 99 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [99] tentando entrar com nome [carinha sorrindo] na sala com nome [neo_sala_2]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 99 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 99 ) ON "Room"."id" = "players"."roomId";
Usuário [99] trocou o nome de [null] para [carinha sorrindo]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer]
    ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer]
    ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_2' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _previousDataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_2] que o usuário [99] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 99);
Tentando adicionar usuário [carinha sorrindo] na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'carinha sorrindo' WHERE "RoomPlayer"."roomId" = 9;
Adicionando usuário [99] à sala [neo_sala_2]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_2
Adicionando usuário [99] para a sala [neo_sala_2] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 9;
Enviando mensagem do sistema [carinha sorrindo tá na área!] para a sala [neo_sala_2]
Emitindo roomData para os sockets conectados na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 9;
emitindo RoomData para todos os sockets do usuário [90]
emitindo roomData para o socket [2itr_g6_1YCsQLWJAAAA] do usuário [90]
emitindo RoomData para todos os sockets do usuário [96]
emitindo roomData para o socket [_LatWm55I6wN7UIAAAAC] do usuário [96]
emitindo RoomData para todos os sockets do usuário [98]
emitindo roomData para o socket [8r4Mni0OLYdzq65lAAAB] do usuário [98]
emitindo RoomData para todos os sockets do usuário [99]
emitindo roomData para o socket [3rwx0vw_pT6rdr0_AAAC] do usuário [99]
emitindo RoomData para todos os sockets do usuário [91]
emitindo RoomData para todos os sockets do usuário [94]
Pegando player do usuário [99] na sala [9]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 99);
Usuário [97] tentando entrar com nome [Pim] na sala com nome [neo_sala_2]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 97 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 97 ) ON "Room"."id" = "players"."roomId";
Usuário [97] trocou o nome de [null] para [Pim]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer]
    ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 9,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_2',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:06:50.925Z,
    updatedAt: 2021-02-14T21:06:50.925Z,
    hostId: 90,
    players: [
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer],
      [RoomPlayer]
    ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_2' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _previousDataValues: {
      id: 90,
      name: 'Pim',
      createdAt: 2021-02-14T21:06:38.656Z,
      updatedAt: 2021-02-14T21:06:50.911Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_2] que o usuário [97] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 9 AND "RoomPlayer"."userId" = 97);
Tentando adicionar usuário [Pim] na sala [neo_sala_2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Pim' WHERE "RoomPlayer"."roomId" = 9;
usuário [Pim] tentando entrar na sala [neo_sala_2] com nome já existente.
Não foi possivel entrar na sala [neo_sala_2]: [esse nome de usuário já existe na sala!]
Usuário [98] com socket [8r4Mni0OLYdzq65lAAAB] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 100
retornando a sala do jogador [gajo] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 98 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 98 ) ON "Room"."id" = "players"."roomId";
CONDIÇÃO AINDA NÃO IMPLEMENTADA!
Usuário [99] com socket [3rwx0vw_pT6rdr0_AAAC] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 101
retornando a sala do jogador [carinha sorrindo] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 99 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 99 ) ON "Room"."id" = "players"."roomId";
CONDIÇÃO AINDA NÃO IMPLEMENTADA!
Usuário [97] tentando entrar com nome [Pim] na sala com nome [neo_sala_3]
retornando a sala do jogador [Pim] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 97 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 97 ) ON "Room"."id" = "players"."roomId";
Usuário [97] trocou o nome de [Pim] para [Pim]
Buscando uma sala com nome [neo_sala_3]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_3' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
null
A sala que o usuário tentou entrar [neo_sala_3] não existe ainda, vamos criar uma para ele
Criando uma sala com nome [neo_sala_3] para o hostPlayer [Pim]
Buscando uma sala com nome [neo_sala_3]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_3' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Procurando uma sala existente [Sala disponível]
Executing (default): INSERT INTO "rooms" ("id","state","name","turn","currentPlayerIndex","prompt","selectedCardCount","victory","votingCardsTurn","winner","minimumPlayersToStart","minimumCardsToStart","selectedDecksIds","deck","morto","results","createdAt","updatedAt","hostId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18) RETURNING *;
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
[]
Sala criada com nome [neo_sala_3] e host player [Pim]
Buscando uma sala com nome [neo_sala_3]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_3' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Sala [neo_sala_3] criada para o usuário [97]
Sala atual é: neo_sala_3
Adicionando usuário [97] para a sala [neo_sala_3] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 10;
Enviando mensagem do sistema [Pim tá na área!] para a sala [neo_sala_3]
Emitindo roomData para os sockets conectados na sala [neo_sala_3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 10;
emitindo RoomData para todos os sockets do usuário [97]
emitindo roomData para o socket [4J5VNxBsJ6KMSOI3AAAA] do usuário [97]
Pegando player do usuário [97] na sala [10]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 10 AND "RoomPlayer"."userId" = 97);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [lv3VTiE8vUlk4ED4AAAD]
Conteúdo de handshake da socket [lv3VTiE8vUlk4ED4AAAD]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/"
  },
  "time": "Sun Feb 14 2021 18:14:15 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337255778,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYPDzV",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYPDzV"
  }
}
Conteúdo da sessão da socket [lv3VTiE8vUlk4ED4AAAD]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:14:15.778Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [lv3VTiE8vUlk4ED4AAAD] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 100,
    updatedAt: 2021-02-14T21:14:15.782Z,
    createdAt: 2021-02-14T21:14:15.782Z,
    name: null
  },
  _previousDataValues: {
    id: 100,
    name: null,
    createdAt: 2021-02-14T21:14:15.782Z,
    updatedAt: 2021-02-14T21:14:15.782Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 100
Usuário adicionado, agora temos [4] usuário(s)
Salvando sessao da socket [lv3VTiE8vUlk4ED4AAAD]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:14:15.778Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 100
}
Ligando o usuário [100] ao socket [102]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 100 AND (("Socket"."id" = 102)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (102)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 100;
Usuário [100] ligado ao socket [102], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 100;
Enviando dados de sessão para o usuário [100]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [100] tentando entrar com nome [gaju] na sala com nome [neo_sala_3]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
Usuário [100] trocou o nome de [null] para [gaju]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_3]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_3' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 10,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_3',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:14:09.570Z,
    updatedAt: 2021-02-14T21:14:09.570Z,
    hostId: 97,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 10,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_3',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:14:09.570Z,
    updatedAt: 2021-02-14T21:14:09.570Z,
    hostId: 97,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_3' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 97,
      name: 'Pim',
      createdAt: 2021-02-14T21:12:49.342Z,
      updatedAt: 2021-02-14T21:13:52.667Z
    },
    _previousDataValues: {
      id: 97,
      name: 'Pim',
      createdAt: 2021-02-14T21:12:49.342Z,
      updatedAt: 2021-02-14T21:13:52.667Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_3] que o usuário [100] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 10 AND "RoomPlayer"."userId" = 100);
Tentando adicionar usuário [gaju] na sala [neo_sala_3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'gaju' WHERE "RoomPlayer"."roomId" = 10;
Adicionando usuário [100] à sala [neo_sala_3]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_3
Adicionando usuário [100] para a sala [neo_sala_3] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 10;
Enviando mensagem do sistema [gaju tá na área!] para a sala [neo_sala_3]
Emitindo roomData para os sockets conectados na sala [neo_sala_3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 10;
emitindo RoomData para todos os sockets do usuário [97]
emitindo roomData para o socket [4J5VNxBsJ6KMSOI3AAAA] do usuário [97]
emitindo RoomData para todos os sockets do usuário [100]
emitindo roomData para o socket [lv3VTiE8vUlk4ED4AAAD] do usuário [100]
Pegando player do usuário [100] na sala [10]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 10 AND "RoomPlayer"."userId" = 100);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [m4HNlgxbfpOmOAz9AAAE]
Conteúdo de handshake da socket [m4HNlgxbfpOmOAz9AAAE]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=lv3VTiE8vUlk4ED4AAAD; connect.sid=s%3AtBRBPJMJM0J7cEBbQjOo9KnKSQQVGmvT.01189EkjkpszVFDcX%2FylS1I7iCdsaV0ipIFcD1wle1s"
  },
  "time": "Sun Feb 14 2021 18:14:30 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337270665,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYPHc7",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYPHc7"
  }
}
Conteúdo da sessão da socket [m4HNlgxbfpOmOAz9AAAE]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:14:30.665Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 100
}
Executing (default): SELECT "id", "name", "createdAt", "updatedAt" FROM "users" AS "User" WHERE "User"."id" = 100;
Detectei o usuário com id [100] para a socket com id [m4HNlgxbfpOmOAz9AAAE]
retornando a sala do jogador [gaju] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
O usuário [100] já está na sala [neo_sala_3], vou mandar os dados da sala para ele!
adicionando socket.id [m4HNlgxbfpOmOAz9AAAE] na socketRoom [neo_sala_3]
Emitindo roomData para os sockets conectados na sala [neo_sala_3]
Ligando o usuário [100] ao socket [103]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 10;
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 100 AND (("Socket"."id" = 103)));
emitindo RoomData para todos os sockets do usuário [97]
emitindo roomData para o socket [4J5VNxBsJ6KMSOI3AAAA] do usuário [97]
emitindo RoomData para todos os sockets do usuário [100]
emitindo roomData para o socket [lv3VTiE8vUlk4ED4AAAD] do usuário [100]
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (103)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 100;
Usuário [100] ligado ao socket [103], agora ele tem [2] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 100;
Enviando dados de sessão para o usuário [100]
retornando a sala do jogador [gaju] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Pegando player do usuário [100] na sala [10]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 10 AND "RoomPlayer"."userId" = 100);
Usuário [100] com socket [m4HNlgxbfpOmOAz9AAAE] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 103
retornando a sala do jogador [gaju] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
CONDIÇÃO AINDA NÃO IMPLEMENTADA!
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [_9FAdGGIy_lLmPSMAAAF]
Conteúdo de handshake da socket [_9FAdGGIy_lLmPSMAAAF]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=m4HNlgxbfpOmOAz9AAAE; connect.sid=s%3AtBRBPJMJM0J7cEBbQjOo9KnKSQQVGmvT.01189EkjkpszVFDcX%2FylS1I7iCdsaV0ipIFcD1wle1s"
  },
  "time": "Sun Feb 14 2021 18:15:01 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337301695,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYPPAu",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYPPAu"
  }
}
Conteúdo da sessão da socket [_9FAdGGIy_lLmPSMAAAF]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:15:01.695Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 100
}
Executing (default): SELECT "id", "name", "createdAt", "updatedAt" FROM "users" AS "User" WHERE "User"."id" = 100;
Detectei o usuário com id [100] para a socket com id [_9FAdGGIy_lLmPSMAAAF]
retornando a sala do jogador [gaju] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
O usuário [100] já está na sala [neo_sala_3], vou mandar os dados da sala para ele!
adicionando socket.id [_9FAdGGIy_lLmPSMAAAF] na socketRoom [neo_sala_3]
Emitindo roomData para os sockets conectados na sala [neo_sala_3]
Ligando o usuário [100] ao socket [104]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 10;
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 100 AND (("Socket"."id" = 104)));
emitindo RoomData para todos os sockets do usuário [97]
emitindo roomData para o socket [4J5VNxBsJ6KMSOI3AAAA] do usuário [97]
emitindo RoomData para todos os sockets do usuário [100]
emitindo roomData para o socket [lv3VTiE8vUlk4ED4AAAD] do usuário [100]
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (104)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 100;
Usuário [100] ligado ao socket [104], agora ele tem [2] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 100;
Enviando dados de sessão para o usuário [100]
retornando a sala do jogador [gaju] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Pegando player do usuário [100] na sala [10]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 10 AND "RoomPlayer"."userId" = 100);
Usuário [97] com socket [4J5VNxBsJ6KMSOI3AAAA] desconectou do servidor
Usuário [100] com socket [lv3VTiE8vUlk4ED4AAAD] desconectou do servidor
Usuário [100] com socket [_9FAdGGIy_lLmPSMAAAF] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 99
Executing (default): DELETE FROM "sockets" WHERE "id" = 102
Executing (default): DELETE FROM "sockets" WHERE "id" = 104
retornando a sala do jogador [Pim] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 97 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 97 ) ON "Room"."id" = "players"."roomId";
CONDIÇÃO AINDA NÃO IMPLEMENTADA!
retornando a sala do jogador [gaju] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
retornando a sala do jogador [gaju] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
CONDIÇÃO AINDA NÃO IMPLEMENTADA!
CONDIÇÃO AINDA NÃO IMPLEMENTADA!
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [zNAMzH_OoOiUVR5JAAAG]
Conteúdo de handshake da socket [zNAMzH_OoOiUVR5JAAAG]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/neo_sala_3",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AI7m-hp4xGDGPPcw7fkBh9XVooSgaQ97E.9HxFHOL8TBTxHDLb6ylwNPrpyWNKN5yYaUCt6AfrlVc; io=4J5VNxBsJ6KMSOI3AAAA"
  },
  "time": "Sun Feb 14 2021 18:16:04 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337364634,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYPeYK",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYPeYK"
  }
}
Conteúdo da sessão da socket [zNAMzH_OoOiUVR5JAAAG]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:16:04.634Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [zNAMzH_OoOiUVR5JAAAG] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 101,
    updatedAt: 2021-02-14T21:16:04.640Z,
    createdAt: 2021-02-14T21:16:04.640Z,
    name: null
  },
  _previousDataValues: {
    id: 101,
    name: null,
    createdAt: 2021-02-14T21:16:04.640Z,
    updatedAt: 2021-02-14T21:16:04.640Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { id: 100 },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 101
Usuário adicionado, agora temos [5] usuário(s)
Salvando sessao da socket [zNAMzH_OoOiUVR5JAAAG]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:16:04.634Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 101
}
Ligando o usuário [101] ao socket [105]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 101 AND (("Socket"."id" = 105)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (105)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 101;
Usuário [101] ligado ao socket [105], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 101;
Enviando dados de sessão para o usuário [101]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 101 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 101 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [VDuqDQ0rkqleSi1fAAAH]
Conteúdo de handshake da socket [VDuqDQ0rkqleSi1fAAAH]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=_9FAdGGIy_lLmPSMAAAF; connect.sid=s%3AtBRBPJMJM0J7cEBbQjOo9KnKSQQVGmvT.01189EkjkpszVFDcX%2FylS1I7iCdsaV0ipIFcD1wle1s"
  },
  "time": "Sun Feb 14 2021 18:16:04 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337364701,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYPeZQ",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYPeZQ"
  }
}
Conteúdo da sessão da socket [VDuqDQ0rkqleSi1fAAAH]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:16:04.701Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 100
}
Executing (default): SELECT "id", "name", "createdAt", "updatedAt" FROM "users" AS "User" WHERE "User"."id" = 100;
Detectei o usuário com id [100] para a socket com id [VDuqDQ0rkqleSi1fAAAH]
retornando a sala do jogador [gaju] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
O usuário [100] já está na sala [neo_sala_3], vou mandar os dados da sala para ele!
adicionando socket.id [VDuqDQ0rkqleSi1fAAAH] na socketRoom [neo_sala_3]
Emitindo roomData para os sockets conectados na sala [neo_sala_3]
Ligando o usuário [100] ao socket [106]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 10;
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 100 AND (("Socket"."id" = 106)));
emitindo RoomData para todos os sockets do usuário [100]
emitindo RoomData para todos os sockets do usuário [97]
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (106)
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 100;
Usuário [100] ligado ao socket [106], agora ele tem [1] socket(s)
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 100;
[io.on('connect') - Nova socket conectada com id [cDnMnrQd2jLKB2n8AAAI]
Conteúdo de handshake da socket [cDnMnrQd2jLKB2n8AAAI]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=VDuqDQ0rkqleSi1fAAAH; connect.sid=s%3AtBRBPJMJM0J7cEBbQjOo9KnKSQQVGmvT.01189EkjkpszVFDcX%2FylS1I7iCdsaV0ipIFcD1wle1s"
  },
  "time": "Sun Feb 14 2021 18:16:04 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337364717,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYPeZd",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYPeZd"
  }
}
Conteúdo da sessão da socket [cDnMnrQd2jLKB2n8AAAI]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:16:04.717Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 100
}
Executing (default): SELECT "id", "name", "createdAt", "updatedAt" FROM "users" AS "User" WHERE "User"."id" = 100;
Enviando dados de sessão para o usuário [100]
retornando a sala do jogador [gaju] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
Detectei o usuário com id [100] para a socket com id [cDnMnrQd2jLKB2n8AAAI]
retornando a sala do jogador [gaju] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 100 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 100 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Pegando player do usuário [100] na sala [10]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 10 AND "RoomPlayer"."userId" = 100);
O usuário [100] já está na sala [neo_sala_3], vou mandar os dados da sala para ele!
adicionando socket.id [cDnMnrQd2jLKB2n8AAAI] na socketRoom [neo_sala_3]
Emitindo roomData para os sockets conectados na sala [neo_sala_3]
Ligando o usuário [100] ao socket [107]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 10;
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 100 AND (("Socket"."id" = 107)));
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:92
        if (player.user.id == user.id) {
                        ^

TypeError: Cannot read property 'id' of undefined
    at /home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:92:25
    at Array.forEach (<anonymous>)
    at Namespace.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:91:24)
    at processTicksAndRejections (node:internal/process/task_queues:94:5)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [rxCx8TL1qWrFtj0GAAAA]
Conteúdo de handshake da socket [rxCx8TL1qWrFtj0GAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=cDnMnrQd2jLKB2n8AAAI; connect.sid=s%3AtBRBPJMJM0J7cEBbQjOo9KnKSQQVGmvT.01189EkjkpszVFDcX%2FylS1I7iCdsaV0ipIFcD1wle1s"
  },
  "time": "Sun Feb 14 2021 18:18:42 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337522844,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYQFAG",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYQFAG"
  }
}
Conteúdo da sessão da socket [rxCx8TL1qWrFtj0GAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:18:42.842Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [rxCx8TL1qWrFtj0GAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 102,
    updatedAt: 2021-02-14T21:18:42.904Z,
    createdAt: 2021-02-14T21:18:42.904Z,
    name: null
  },
  _previousDataValues: {
    id: 102,
    name: null,
    createdAt: 2021-02-14T21:18:42.904Z,
    updatedAt: 2021-02-14T21:18:42.904Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 102
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [rxCx8TL1qWrFtj0GAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:18:42.842Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 102
}
Ligando o usuário [102] ao socket [108]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 102 AND (("Socket"."id" = 108)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (108)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 102;
Usuário [102] ligado ao socket [108], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [102]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 102 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 102 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [jSp_UAgCl0VaHClKAAAB]
Conteúdo de handshake da socket [jSp_UAgCl0VaHClKAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=rxCx8TL1qWrFtj0GAAAA; connect.sid=s%3AgaNDTJDB2XlnphFYjT5hRchtNAXHxk8A.uZk1zOdeJSkXYOVpS0UnrDl8QIdxQT4hNqQJkGl%2B9kc"
  },
  "time": "Sun Feb 14 2021 18:18:46 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337526361,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYQG1N",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYQG1N"
  }
}
Conteúdo da sessão da socket [jSp_UAgCl0VaHClKAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:18:46.361Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [jSp_UAgCl0VaHClKAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 103,
    updatedAt: 2021-02-14T21:18:46.371Z,
    createdAt: 2021-02-14T21:18:46.371Z,
    name: null
  },
  _previousDataValues: {
    id: 103,
    name: null,
    createdAt: 2021-02-14T21:18:46.371Z,
    updatedAt: 2021-02-14T21:18:46.371Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 103
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [jSp_UAgCl0VaHClKAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:18:46.361Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 103
}
Ligando o usuário [103] ao socket [109]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 103 AND (("Socket"."id" = 109)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (109)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 103;
Usuário [103] ligado ao socket [109], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [103]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 103 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 103 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [jIWJdzlyT7spiTb5AAAC]
Conteúdo de handshake da socket [jIWJdzlyT7spiTb5AAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/neo_sala_3",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AI7m-hp4xGDGPPcw7fkBh9XVooSgaQ97E.9HxFHOL8TBTxHDLb6ylwNPrpyWNKN5yYaUCt6AfrlVc; io=zNAMzH_OoOiUVR5JAAAG"
  },
  "time": "Sun Feb 14 2021 18:18:46 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337526467,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYQG30",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYQG30"
  }
}
Conteúdo da sessão da socket [jIWJdzlyT7spiTb5AAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:18:46.467Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [jIWJdzlyT7spiTb5AAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 104,
    updatedAt: 2021-02-14T21:18:46.474Z,
    createdAt: 2021-02-14T21:18:46.474Z,
    name: null
  },
  _previousDataValues: {
    id: 104,
    name: null,
    createdAt: 2021-02-14T21:18:46.474Z,
    updatedAt: 2021-02-14T21:18:46.474Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 104
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [jIWJdzlyT7spiTb5AAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:18:46.467Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 104
}
Ligando o usuário [104] ao socket [110]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 104 AND (("Socket"."id" = 110)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (110)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 104;
Usuário [104] ligado ao socket [110], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [104]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 104 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 104 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [103] com socket [jSp_UAgCl0VaHClKAAAB] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 109
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 103 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 103 ) ON "Room"."id" = "players"."roomId";
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:339
      if (user.socketIds.length == 0 && userRoom.state !== "WAITING_FOR_PLAYERS") {
                         ^

TypeError: Cannot read property 'length' of undefined
    at Socket.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:339:26)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [YKApmKYa5GXVML8YAAAA]
Conteúdo de handshake da socket [YKApmKYa5GXVML8YAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=jSp_UAgCl0VaHClKAAAB; connect.sid=s%3AgaNDTJDB2XlnphFYjT5hRchtNAXHxk8A.uZk1zOdeJSkXYOVpS0UnrDl8QIdxQT4hNqQJkGl%2B9kc"
  },
  "time": "Sun Feb 14 2021 18:19:55 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337595778,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYQWzd",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYQWzd"
  }
}
Conteúdo da sessão da socket [YKApmKYa5GXVML8YAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:19:55.774Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [YKApmKYa5GXVML8YAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 105,
    updatedAt: 2021-02-14T21:19:55.831Z,
    createdAt: 2021-02-14T21:19:55.831Z,
    name: null
  },
  _previousDataValues: {
    id: 105,
    name: null,
    createdAt: 2021-02-14T21:19:55.831Z,
    updatedAt: 2021-02-14T21:19:55.831Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 105
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [YKApmKYa5GXVML8YAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:19:55.774Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 105
}
Ligando o usuário [105] ao socket [111]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 105 AND (("Socket"."id" = 111)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (111)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 105;
Usuário [105] ligado ao socket [111], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [105]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 105 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 105 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [JNhZ2QwUJLzgGKCxAAAB]
Conteúdo de handshake da socket [JNhZ2QwUJLzgGKCxAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_3",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AM3OQGh6FvuhSM5XsMDHsiGS-fJlB42oP.LcCC28yqEre73PWoPo0ngdViOuv%2FWRQpV4BQRe2hc%2Fg; io=jIWJdzlyT7spiTb5AAAC"
  },
  "time": "Sun Feb 14 2021 18:19:58 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337598390,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYQXcf",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYQXcf"
  }
}
Conteúdo da sessão da socket [JNhZ2QwUJLzgGKCxAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:19:58.389Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [JNhZ2QwUJLzgGKCxAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 106,
    updatedAt: 2021-02-14T21:19:58.407Z,
    createdAt: 2021-02-14T21:19:58.407Z,
    name: null
  },
  _previousDataValues: {
    id: 106,
    name: null,
    createdAt: 2021-02-14T21:19:58.407Z,
    updatedAt: 2021-02-14T21:19:58.407Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 106
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [JNhZ2QwUJLzgGKCxAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:19:58.389Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 106
}
Ligando o usuário [106] ao socket [112]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 106 AND (("Socket"."id" = 112)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (112)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 106;
Usuário [106] ligado ao socket [112], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [106]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 106 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 106 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [105] com socket [YKApmKYa5GXVML8YAAAA] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 111
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 105 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 105 ) ON "Room"."id" = "players"."roomId";
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:339
      if (user.socketIds.length == 0 && userRoom.state !== "WAITING_FOR_PLAYERS") {
                         ^

TypeError: Cannot read property 'length' of undefined
    at Socket.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:339:26)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [mUEB5veQeIMQPE28AAAA]
Conteúdo de handshake da socket [mUEB5veQeIMQPE28AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_3",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3A8eMjW3IWw89J0MgDIJPSvP3qlG7iFwDC.LT7oTxsSOuHtr1UbI6eKb9orkhAdaXRUWD%2F4X6g%2FOKA; io=JNhZ2QwUJLzgGKCxAAAB"
  },
  "time": "Sun Feb 14 2021 18:21:07 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337667379,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYQoSM",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYQoSM"
  }
}
Conteúdo da sessão da socket [mUEB5veQeIMQPE28AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:21:07.375Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [mUEB5veQeIMQPE28AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 107,
    updatedAt: 2021-02-14T21:21:07.433Z,
    createdAt: 2021-02-14T21:21:07.433Z,
    name: null
  },
  _previousDataValues: {
    id: 107,
    name: null,
    createdAt: 2021-02-14T21:21:07.433Z,
    updatedAt: 2021-02-14T21:21:07.433Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 107
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [mUEB5veQeIMQPE28AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:21:07.375Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 107
}
Ligando o usuário [107] ao socket [113]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 107 AND (("Socket"."id" = 113)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (113)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 107;
Usuário [107] ligado ao socket [113], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [107]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 107 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 107 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [0w7guLS2SUkcKpa1AAAA]
Conteúdo de handshake da socket [0w7guLS2SUkcKpa1AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_3",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3A9QVwgUeC5TS_83A7lLkzig1RKw56sxrU.f0QoSsbyIfwJGZo7%2BT0B3wycDJwhwlz8RXGNJ%2FMD744; io=mUEB5veQeIMQPE28AAAA"
  },
  "time": "Sun Feb 14 2021 18:21:34 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337694199,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYQu_h",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYQu_h"
  }
}
Conteúdo da sessão da socket [0w7guLS2SUkcKpa1AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:21:34.197Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [0w7guLS2SUkcKpa1AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 108,
    updatedAt: 2021-02-14T21:21:34.248Z,
    createdAt: 2021-02-14T21:21:34.248Z,
    name: null
  },
  _previousDataValues: {
    id: 108,
    name: null,
    createdAt: 2021-02-14T21:21:34.248Z,
    updatedAt: 2021-02-14T21:21:34.248Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 108
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [0w7guLS2SUkcKpa1AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:21:34.197Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 108
}
Ligando o usuário [108] ao socket [114]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 108 AND (("Socket"."id" = 114)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (114)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 108;
Usuário [108] ligado ao socket [114], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [108]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 108 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 108 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [108] com socket [0w7guLS2SUkcKpa1AAAA] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 114
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 108 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 108 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 108;
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:340
      if (userSockets.length == 0 && userRoom.state !== "WAITING_FOR_PLAYERS") {
                                              ^

TypeError: Cannot read property 'state' of null
    at Socket.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:340:47)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [30V3i4oQGZii3XnmAAAA]
Conteúdo de handshake da socket [30V3i4oQGZii3XnmAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AcRGo9J-aZuz4xJlsjrSAuY2XLWKjLhLT.NAR0VHEFmd0wUeuhtKyXzO13BKFGHcsUMZyPZNA%2BOOE; io=0w7guLS2SUkcKpa1AAAA"
  },
  "time": "Sun Feb 14 2021 18:22:36 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337756840,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYR8IL",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYR8IL"
  }
}
Conteúdo da sessão da socket [30V3i4oQGZii3XnmAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:22:36.838Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [30V3i4oQGZii3XnmAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 109,
    updatedAt: 2021-02-14T21:22:36.886Z,
    createdAt: 2021-02-14T21:22:36.886Z,
    name: null
  },
  _previousDataValues: {
    id: 109,
    name: null,
    createdAt: 2021-02-14T21:22:36.886Z,
    updatedAt: 2021-02-14T21:22:36.886Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 109
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [30V3i4oQGZii3XnmAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:22:36.838Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 109
}
Ligando o usuário [109] ao socket [115]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 109 AND (("Socket"."id" = 115)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (115)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 109;
Usuário [109] ligado ao socket [115], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [109]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 109 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 109 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [109] com socket [30V3i4oQGZii3XnmAAAA] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 115
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 109 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 109 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 109;
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:340
      if (userSockets.length == 0 && userRoom.state !== "WAITING_FOR_PLAYERS") {
                                              ^

TypeError: Cannot read property 'state' of null
    at Socket.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:340:47)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [8i9oWTsubGDxImlXAAAA]
Conteúdo de handshake da socket [8i9oWTsubGDxImlXAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AOc9p_ZbDg5eoyIDUAAC65t3U8CIvIrqD.TU9RvnBHjeXhGZSDjKkSxqBtDJ%2BKUTPBTWHO8y56b7Q; io=30V3i4oQGZii3XnmAAAA"
  },
  "time": "Sun Feb 14 2021 18:23:11 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337791910,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYRGsM",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYRGsM"
  }
}
Conteúdo da sessão da socket [8i9oWTsubGDxImlXAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:23:11.908Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [8i9oWTsubGDxImlXAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 110,
    updatedAt: 2021-02-14T21:23:11.961Z,
    createdAt: 2021-02-14T21:23:11.961Z,
    name: null
  },
  _previousDataValues: {
    id: 110,
    name: null,
    createdAt: 2021-02-14T21:23:11.961Z,
    updatedAt: 2021-02-14T21:23:11.961Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 110
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [8i9oWTsubGDxImlXAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:23:11.908Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 110
}
Ligando o usuário [110] ao socket [116]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 110 AND (("Socket"."id" = 116)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (116)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 110;
Usuário [110] ligado ao socket [116], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [110]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 110 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 110 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [110] com socket [8i9oWTsubGDxImlXAAAA] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 116
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 110 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 110 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 110;
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [bMUvExKK0wxqbgE5AAAB]
Conteúdo de handshake da socket [bMUvExKK0wxqbgE5AAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3ARotQlLGlOiFtR03hy_Igjmf6ITDnAktQ.NvnFbbmZfvi8yKUV4A3Jjh4hDmcPOlZRKOb24gOFEno; io=8i9oWTsubGDxImlXAAAA"
  },
  "time": "Sun Feb 14 2021 18:23:14 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337794425,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYRHTu",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYRHTu"
  }
}
Conteúdo da sessão da socket [bMUvExKK0wxqbgE5AAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:23:14.425Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 110
}
Executing (default): SELECT "id", "name", "createdAt", "updatedAt" FROM "users" AS "User" WHERE "User"."id" = 110;
Detectei o usuário com id [110] para a socket com id [bMUvExKK0wxqbgE5AAAB]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 110 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 110 ) ON "Room"."id" = "players"."roomId";
Ligando o usuário [110] ao socket [117]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 110 AND (("Socket"."id" = 117)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (117)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 110;
Usuário [110] ligado ao socket [117], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [110]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 110 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 110 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [110] tentando entrar com nome [Pim] na sala com nome [neo_sala_666]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 110 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 110 ) ON "Room"."id" = "players"."roomId";
Usuário [110] trocou o nome de [null] para [Pim]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_666]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_666' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
null
A sala que o usuário tentou entrar [neo_sala_666] não existe ainda, vamos criar uma para ele
Criando uma sala com nome [neo_sala_666] para o hostPlayer [Pim]
Buscando uma sala com nome [neo_sala_666]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_666' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Procurando uma sala existente [Sala disponível]
Executing (default): INSERT INTO "rooms" ("id","state","name","turn","currentPlayerIndex","prompt","selectedCardCount","victory","votingCardsTurn","winner","minimumPlayersToStart","minimumCardsToStart","selectedDecksIds","deck","morto","results","createdAt","updatedAt","hostId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18) RETURNING *;
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
[]
Sala criada com nome [neo_sala_666] e host player [Pim]
Buscando uma sala com nome [neo_sala_666]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_666' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Sala [neo_sala_666] criada para o usuário [110]
Sala atual é: neo_sala_666
Adicionando usuário [110] para a sala [neo_sala_666] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 11;
Enviando mensagem do sistema [Pim tá na área!] para a sala [neo_sala_666]
Emitindo roomData para os sockets conectados na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 11;
emitindo RoomData para todos os sockets do usuário [110]
emitindo roomData para o socket [bMUvExKK0wxqbgE5AAAB] do usuário [110]
Pegando player do usuário [110] na sala [11]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 110);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [nD0kqL1UgMU4epUDAAAC]
Conteúdo de handshake da socket [nD0kqL1UgMU4epUDAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/"
  },
  "time": "Sun Feb 14 2021 18:23:41 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337821387,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYRO39",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYRO39"
  }
}
Conteúdo da sessão da socket [nD0kqL1UgMU4epUDAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:23:41.387Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [nD0kqL1UgMU4epUDAAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 111,
    updatedAt: 2021-02-14T21:23:41.395Z,
    createdAt: 2021-02-14T21:23:41.395Z,
    name: null
  },
  _previousDataValues: {
    id: 111,
    name: null,
    createdAt: 2021-02-14T21:23:41.395Z,
    updatedAt: 2021-02-14T21:23:41.395Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { id: 110 },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 111
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [nD0kqL1UgMU4epUDAAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:23:41.387Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 111
}
Ligando o usuário [111] ao socket [118]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 111 AND (("Socket"."id" = 118)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (118)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 111;
Usuário [111] ligado ao socket [118], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [111]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 111 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 111 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [111] tentando entrar com nome [Pim2] na sala com nome [neo_sala_666]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 111 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 111 ) ON "Room"."id" = "players"."roomId";
Usuário [111] trocou o nome de [null] para [Pim2]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_666]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_666' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 11,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_666',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:23:36.085Z,
    updatedAt: 2021-02-14T21:23:36.085Z,
    hostId: 110,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 11,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_666',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:23:36.085Z,
    updatedAt: 2021-02-14T21:23:36.085Z,
    hostId: 110,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_666' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 110,
      name: 'Pim',
      createdAt: 2021-02-14T21:23:11.961Z,
      updatedAt: 2021-02-14T21:23:36.060Z
    },
    _previousDataValues: {
      id: 110,
      name: 'Pim',
      createdAt: 2021-02-14T21:23:11.961Z,
      updatedAt: 2021-02-14T21:23:36.060Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: [Object],
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_666] que o usuário [111] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 111);
Tentando adicionar usuário [Pim2] na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Pim2' WHERE "RoomPlayer"."roomId" = 11;
Adicionando usuário [111] à sala [neo_sala_666]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_666
Adicionando usuário [111] para a sala [neo_sala_666] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 11;
Enviando mensagem do sistema [Pim2 tá na área!] para a sala [neo_sala_666]
Emitindo roomData para os sockets conectados na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 11;
emitindo RoomData para todos os sockets do usuário [110]
emitindo roomData para o socket [bMUvExKK0wxqbgE5AAAB] do usuário [110]
emitindo RoomData para todos os sockets do usuário [111]
emitindo roomData para o socket [nD0kqL1UgMU4epUDAAAC] do usuário [111]
Pegando player do usuário [111] na sala [11]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 111);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [e1Uz1zmhYoIcFJKxAAAD]
Conteúdo de handshake da socket [e1Uz1zmhYoIcFJKxAAAD]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=nD0kqL1UgMU4epUDAAAC; connect.sid=s%3A6dSSd2C7sQ0vyHIcJoGnwmI2eT5ZmRTY.ogBaUJEjzKpVkue3dlvb06%2F6ISeSo4iCcP8wGoK8r84"
  },
  "time": "Sun Feb 14 2021 18:23:53 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337833290,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYRQz7",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYRQz7"
  }
}
Conteúdo da sessão da socket [e1Uz1zmhYoIcFJKxAAAD]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:23:53.290Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 111
}
Executing (default): SELECT "id", "name", "createdAt", "updatedAt" FROM "users" AS "User" WHERE "User"."id" = 111;
Detectei o usuário com id [111] para a socket com id [e1Uz1zmhYoIcFJKxAAAD]
retornando a sala do jogador [Pim2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 111 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 111 ) ON "Room"."id" = "players"."roomId";
O usuário [111] já está na sala [neo_sala_666], vou mandar os dados da sala para ele!
adicionando socket.id [e1Uz1zmhYoIcFJKxAAAD] na socketRoom [neo_sala_666]
Emitindo roomData para os sockets conectados na sala [neo_sala_666]
Ligando o usuário [111] ao socket [119]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 11;
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 111 AND (("Socket"."id" = 119)));
emitindo RoomData para todos os sockets do usuário [110]
emitindo roomData para o socket [bMUvExKK0wxqbgE5AAAB] do usuário [110]
emitindo RoomData para todos os sockets do usuário [111]
emitindo roomData para o socket [nD0kqL1UgMU4epUDAAAC] do usuário [111]
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (119)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 111;
Usuário [111] ligado ao socket [119], agora ele tem [2] socket(s)
Enviando dados de sessão para o usuário [111]
retornando a sala do jogador [Pim2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 111 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 111 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Pegando player do usuário [111] na sala [11]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 111);
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:87
    if (user.socketIds.length == 1) {
                       ^

TypeError: Cannot read property 'length' of undefined
    at Namespace.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:87:24)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [Q0u6jgRnqOMXQyVYAAAA]
Conteúdo de handshake da socket [Q0u6jgRnqOMXQyVYAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=e1Uz1zmhYoIcFJKxAAAD; connect.sid=s%3A6dSSd2C7sQ0vyHIcJoGnwmI2eT5ZmRTY.ogBaUJEjzKpVkue3dlvb06%2F6ISeSo4iCcP8wGoK8r84"
  },
  "time": "Sun Feb 14 2021 18:25:40 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337940618,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYRr9w",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYRr9w"
  }
}
Conteúdo da sessão da socket [Q0u6jgRnqOMXQyVYAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:25:40.616Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [Q0u6jgRnqOMXQyVYAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 112,
    updatedAt: 2021-02-14T21:25:40.674Z,
    createdAt: 2021-02-14T21:25:40.674Z,
    name: null
  },
  _previousDataValues: {
    id: 112,
    name: null,
    createdAt: 2021-02-14T21:25:40.674Z,
    updatedAt: 2021-02-14T21:25:40.674Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 112
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [Q0u6jgRnqOMXQyVYAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:25:40.616Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 112
}
Ligando o usuário [112] ao socket [120]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 112 AND (("Socket"."id" = 120)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (120)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 112;
Usuário [112] ligado ao socket [120], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [112]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 112 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 112 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [ohi2gBiZmkr82hmTAAAB]
Conteúdo de handshake da socket [ohi2gBiZmkr82hmTAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/neo_sala_666",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3ARotQlLGlOiFtR03hy_Igjmf6ITDnAktQ.NvnFbbmZfvi8yKUV4A3Jjh4hDmcPOlZRKOb24gOFEno; io=bMUvExKK0wxqbgE5AAAB"
  },
  "time": "Sun Feb 14 2021 18:25:42 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337942690,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYRrgR",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYRrgR"
  }
}
Conteúdo da sessão da socket [ohi2gBiZmkr82hmTAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:25:42.689Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [ohi2gBiZmkr82hmTAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 113,
    updatedAt: 2021-02-14T21:25:42.703Z,
    createdAt: 2021-02-14T21:25:42.703Z,
    name: null
  },
  _previousDataValues: {
    id: 113,
    name: null,
    createdAt: 2021-02-14T21:25:42.703Z,
    updatedAt: 2021-02-14T21:25:42.703Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 113
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [ohi2gBiZmkr82hmTAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:25:42.689Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 113
}
Ligando o usuário [113] ao socket [121]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 113 AND (("Socket"."id" = 121)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (121)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 113;
Usuário [113] ligado ao socket [121], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [113]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 113 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 113 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [zEynIm968AVhBfbwAAAC]
Conteúdo de handshake da socket [zEynIm968AVhBfbwAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=Q0u6jgRnqOMXQyVYAAAA; connect.sid=s%3ARmKAafSc4-C-p7_NzoAchAcUofik8Vc7.u4pkSBrLxn2ofmtnGnz%2F%2BlhRu6pP8iyQafCZHlgabPE"
  },
  "time": "Sun Feb 14 2021 18:25:43 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613337943379,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYRrrC",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYRrrC"
  }
}
Conteúdo da sessão da socket [zEynIm968AVhBfbwAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:25:43.378Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [zEynIm968AVhBfbwAAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 114,
    updatedAt: 2021-02-14T21:25:43.399Z,
    createdAt: 2021-02-14T21:25:43.399Z,
    name: null
  },
  _previousDataValues: {
    id: 114,
    name: null,
    createdAt: 2021-02-14T21:25:43.399Z,
    updatedAt: 2021-02-14T21:25:43.399Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 114
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [zEynIm968AVhBfbwAAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:25:43.378Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 114
}
Ligando o usuário [114] ao socket [122]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 114 AND (("Socket"."id" = 122)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (122)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 114;
Usuário [114] ligado ao socket [122], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [114]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 114 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 114 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [qwIqK-F_d0eDFYLGAAAA]
Conteúdo de handshake da socket [qwIqK-F_d0eDFYLGAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=zEynIm968AVhBfbwAAAC; connect.sid=s%3ARmKAafSc4-C-p7_NzoAchAcUofik8Vc7.u4pkSBrLxn2ofmtnGnz%2F%2BlhRu6pP8iyQafCZHlgabPE"
  },
  "time": "Sun Feb 14 2021 18:26:55 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338015249,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYS7O4",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYS7O4"
  }
}
Conteúdo da sessão da socket [qwIqK-F_d0eDFYLGAAAA]: {
  "cookie": {
    "originalMaxAge": 2591999999,
    "expires": "2021-03-16T21:26:55.246Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [qwIqK-F_d0eDFYLGAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 115,
    updatedAt: 2021-02-14T21:26:55.300Z,
    createdAt: 2021-02-14T21:26:55.300Z,
    name: null
  },
  _previousDataValues: {
    id: 115,
    name: null,
    createdAt: 2021-02-14T21:26:55.300Z,
    updatedAt: 2021-02-14T21:26:55.300Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 115
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [qwIqK-F_d0eDFYLGAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:26:55.246Z,
    originalMaxAge: 2591999999,
    httpOnly: true
  },
  userId: 115
}
Ligando o usuário [115] ao socket [123]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 115 AND (("Socket"."id" = 123)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (123)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 115;
Usuário [115] ligado ao socket [123], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [115]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 115 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 115 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [tuFYB-w4UVKvl3pXAAAB]
Conteúdo de handshake da socket [tuFYB-w4UVKvl3pXAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_666",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3ATfHqqBR-A2K9kbG2yY3M_4Wbjga6ztcT.dhPefHFzlaSXeHwJsOmJAajQjTZKByK1d%2Bw8c%2BvRf1U; io=ohi2gBiZmkr82hmTAAAB"
  },
  "time": "Sun Feb 14 2021 18:26:55 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338015739,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYS7Vu",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYS7Vu"
  }
}
Conteúdo da sessão da socket [tuFYB-w4UVKvl3pXAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:26:55.739Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [tuFYB-w4UVKvl3pXAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 116,
    updatedAt: 2021-02-14T21:26:55.746Z,
    createdAt: 2021-02-14T21:26:55.746Z,
    name: null
  },
  _previousDataValues: {
    id: 116,
    name: null,
    createdAt: 2021-02-14T21:26:55.746Z,
    updatedAt: 2021-02-14T21:26:55.746Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 116
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [tuFYB-w4UVKvl3pXAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:26:55.739Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 116
}
Ligando o usuário [116] ao socket [124]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 116 AND (("Socket"."id" = 124)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (124)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 116;
Usuário [116] ligado ao socket [124], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [116]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 116 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 116 ) ON "Room"."id" = "players"."roomId";
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
verificando se existem dados de partida para o usuário
[io.on('connect') - Nova socket conectada com id [UlLtjybt0LlvDjobAAAC]
Conteúdo de handshake da socket [UlLtjybt0LlvDjobAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=qwIqK-F_d0eDFYLGAAAA; connect.sid=s%3Asf3MVHw-uhKtfa1EdpazII_Enpgwc9nA.hZUGR61RYY6TsbpUEqjSk1ZPJr%2FbFbne1JSiUxIvZdk"
  },
  "time": "Sun Feb 14 2021 18:26:55 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338015767,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYS7WK",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYS7WK"
  }
}
Conteúdo da sessão da socket [UlLtjybt0LlvDjobAAAC]: {
  "cookie": {
    "originalMaxAge": 2591999999,
    "expires": "2021-03-16T21:26:55.766Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [UlLtjybt0LlvDjobAAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 117,
    updatedAt: 2021-02-14T21:26:55.775Z,
    createdAt: 2021-02-14T21:26:55.775Z,
    name: null
  },
  _previousDataValues: {
    id: 117,
    name: null,
    createdAt: 2021-02-14T21:26:55.775Z,
    updatedAt: 2021-02-14T21:26:55.775Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 117
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [UlLtjybt0LlvDjobAAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:26:55.766Z,
    originalMaxAge: 2591999999,
    httpOnly: true
  },
  userId: 117
}
Ligando o usuário [117] ao socket [125]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 117 AND (("Socket"."id" = 125)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (125)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 117;
Usuário [117] ligado ao socket [125], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [117]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 117 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 117 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [34FoTMMh0tpB7ocnAAAA]
Conteúdo de handshake da socket [34FoTMMh0tpB7ocnAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_666",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3A4OJ7yJSE2dktCSyfLUkqZ8s64L7OJHcM.6rZZPujKc5Md28OglzFTNYsJjPXsHlQugMdxazoc7UA; io=tuFYB-w4UVKvl3pXAAAB"
  },
  "time": "Sun Feb 14 2021 18:27:42 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338062429,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSIuu",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSIuu"
  }
}
Conteúdo da sessão da socket [34FoTMMh0tpB7ocnAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:27:42.424Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [34FoTMMh0tpB7ocnAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 118,
    updatedAt: 2021-02-14T21:27:42.509Z,
    createdAt: 2021-02-14T21:27:42.509Z,
    name: null
  },
  _previousDataValues: {
    id: 118,
    name: null,
    createdAt: 2021-02-14T21:27:42.509Z,
    updatedAt: 2021-02-14T21:27:42.509Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 118
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [34FoTMMh0tpB7ocnAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:27:42.424Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 118
}
Ligando o usuário [118] ao socket [126]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 118 AND (("Socket"."id" = 126)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (126)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 118;
Usuário [118] ligado ao socket [126], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [118]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 118 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 118 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [LBHB0f8PogGwxnnuAAAB]
Conteúdo de handshake da socket [LBHB0f8PogGwxnnuAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=UlLtjybt0LlvDjobAAAC; connect.sid=s%3Asf3MVHw-uhKtfa1EdpazII_Enpgwc9nA.hZUGR61RYY6TsbpUEqjSk1ZPJr%2FbFbne1JSiUxIvZdk"
  },
  "time": "Sun Feb 14 2021 18:27:42 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338062921,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSJ0_",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSJ0_"
  }
}
Conteúdo da sessão da socket [LBHB0f8PogGwxnnuAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:27:42.920Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [LBHB0f8PogGwxnnuAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 119,
    updatedAt: 2021-02-14T21:27:42.941Z,
    createdAt: 2021-02-14T21:27:42.941Z,
    name: null
  },
  _previousDataValues: {
    id: 119,
    name: null,
    createdAt: 2021-02-14T21:27:42.941Z,
    updatedAt: 2021-02-14T21:27:42.941Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 119
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [LBHB0f8PogGwxnnuAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:27:42.920Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 119
}
Ligando o usuário [119] ao socket [127]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 119 AND (("Socket"."id" = 127)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (127)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 119;
Usuário [119] ligado ao socket [127], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [119]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 119 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 119 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [BylWt_bmK_XBBNftAAAC]
Conteúdo de handshake da socket [BylWt_bmK_XBBNftAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=LBHB0f8PogGwxnnuAAAB; connect.sid=s%3AhICcmBbXOsU6FjdgiCsY4IkX98vxY7lO.zzA4Tx9hDsJN57guuoSqvJG2o86MS3D%2FYiwIB7nnkNU"
  },
  "time": "Sun Feb 14 2021 18:27:43 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338063021,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSJ2g",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSJ2g"
  }
}
Conteúdo da sessão da socket [BylWt_bmK_XBBNftAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:27:43.020Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [BylWt_bmK_XBBNftAAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 120,
    updatedAt: 2021-02-14T21:27:43.029Z,
    createdAt: 2021-02-14T21:27:43.029Z,
    name: null
  },
  _previousDataValues: {
    id: 120,
    name: null,
    createdAt: 2021-02-14T21:27:43.029Z,
    updatedAt: 2021-02-14T21:27:43.029Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 120
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [BylWt_bmK_XBBNftAAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:27:43.020Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 120
}
Ligando o usuário [120] ao socket [128]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 120 AND (("Socket"."id" = 128)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (128)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 120;
Usuário [120] ligado ao socket [128], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [120]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 120 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 120 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [T_wuRAsDTqvzgCqDAAAA]
Conteúdo de handshake da socket [T_wuRAsDTqvzgCqDAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=BylWt_bmK_XBBNftAAAC; connect.sid=s%3AhICcmBbXOsU6FjdgiCsY4IkX98vxY7lO.zzA4Tx9hDsJN57guuoSqvJG2o86MS3D%2FYiwIB7nnkNU"
  },
  "time": "Sun Feb 14 2021 18:28:38 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338118820,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSWfy",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSWfy"
  }
}
Conteúdo da sessão da socket [T_wuRAsDTqvzgCqDAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:28:38.816Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [T_wuRAsDTqvzgCqDAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
[io.on('connect') - Nova socket conectada com id [idBN8EgKLTaRM98AAAAB]
Conteúdo de handshake da socket [idBN8EgKLTaRM98AAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=BylWt_bmK_XBBNftAAAC; connect.sid=s%3AhICcmBbXOsU6FjdgiCsY4IkX98vxY7lO.zzA4Tx9hDsJN57guuoSqvJG2o86MS3D%2FYiwIB7nnkNU"
  },
  "time": "Sun Feb 14 2021 18:28:38 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338118851,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSWg9",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSWg9"
  }
}
Conteúdo da sessão da socket [idBN8EgKLTaRM98AAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:28:38.850Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [idBN8EgKLTaRM98AAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
[io.on('connect') - Nova socket conectada com id [5YvmcNkhwakJNJP9AAAC]
Conteúdo de handshake da socket [5YvmcNkhwakJNJP9AAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_666",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AwaaWWP6bJdAkIth3_Us-VtZO6AieACI8.MFrGFCaSdBS6ana6s43EuEQoA%2B%2FXawGBcwTvsyGy0X8; io=34FoTMMh0tpB7ocnAAAA"
  },
  "time": "Sun Feb 14 2021 18:28:38 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338118860,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSWh6",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSWh6"
  }
}
Conteúdo da sessão da socket [5YvmcNkhwakJNJP9AAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:28:38.860Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [5YvmcNkhwakJNJP9AAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 121,
    updatedAt: 2021-02-14T21:28:38.884Z,
    createdAt: 2021-02-14T21:28:38.884Z,
    name: null
  },
  _previousDataValues: {
    id: 121,
    name: null,
    createdAt: 2021-02-14T21:28:38.884Z,
    updatedAt: 2021-02-14T21:28:38.884Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 121
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [T_wuRAsDTqvzgCqDAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:28:38.816Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 121
}
Ligando o usuário [121] ao socket [130]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 121 AND (("Socket"."id" = 130)));
User {
  dataValues: {
    id: 122,
    updatedAt: 2021-02-14T21:28:38.886Z,
    createdAt: 2021-02-14T21:28:38.886Z,
    name: null
  },
  _previousDataValues: {
    id: 122,
    name: null,
    createdAt: 2021-02-14T21:28:38.886Z,
    updatedAt: 2021-02-14T21:28:38.886Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 122
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [idBN8EgKLTaRM98AAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:28:38.850Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 122
}
Ligando o usuário [122] ao socket [131]
User {
  dataValues: {
    id: 123,
    updatedAt: 2021-02-14T21:28:38.886Z,
    createdAt: 2021-02-14T21:28:38.886Z,
    name: null
  },
  _previousDataValues: {
    id: 123,
    name: null,
    createdAt: 2021-02-14T21:28:38.886Z,
    updatedAt: 2021-02-14T21:28:38.886Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 123
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [5YvmcNkhwakJNJP9AAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:28:38.860Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 123
}
Ligando o usuário [123] ao socket [129]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 122 AND (("Socket"."id" = 131)));
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 123 AND (("Socket"."id" = 129)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (130)
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (131)
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (129)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 121;
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 122;
Usuário [121] ligado ao socket [130], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [121]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 123;
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 121 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 121 ) ON "Room"."id" = "players"."roomId";
Usuário [122] ligado ao socket [131], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [122]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 122 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 122 ) ON "Room"."id" = "players"."roomId";
Usuário [123] ligado ao socket [129], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [123]
retornando a sala do jogador [null] se ele estiver em uma
verificando se existem dados de partida para o usuário
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 123 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 123 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
verificando se existem dados de partida para o usuário
Usuário [122] tentando entrar com nome [Pim3] na sala com nome [neo_sala_666]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 122 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 122 ) ON "Room"."id" = "players"."roomId";
Usuário [122] trocou o nome de [null] para [Pim3]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_666]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_666' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 11,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_666',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:23:36.085Z,
    updatedAt: 2021-02-14T21:23:36.085Z,
    hostId: 110,
    players: [ [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 11,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_666',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:23:36.085Z,
    updatedAt: 2021-02-14T21:23:36.085Z,
    hostId: 110,
    players: [ [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_666' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 110,
      name: 'Pim',
      createdAt: 2021-02-14T21:23:11.961Z,
      updatedAt: 2021-02-14T21:23:36.060Z
    },
    _previousDataValues: {
      id: 110,
      name: 'Pim',
      createdAt: 2021-02-14T21:23:11.961Z,
      updatedAt: 2021-02-14T21:23:36.060Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_666] que o usuário [122] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 122);
Tentando adicionar usuário [Pim3] na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Pim3' WHERE "RoomPlayer"."roomId" = 11;
Adicionando usuário [122] à sala [neo_sala_666]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_666
Adicionando usuário [122] para a sala [neo_sala_666] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 11;
Enviando mensagem do sistema [Pim3 tá na área!] para a sala [neo_sala_666]
Emitindo roomData para os sockets conectados na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 11;
emitindo RoomData para todos os sockets do usuário [110]
emitindo roomData para o socket [bMUvExKK0wxqbgE5AAAB] do usuário [110]
emitindo RoomData para todos os sockets do usuário [111]
emitindo roomData para o socket [nD0kqL1UgMU4epUDAAAC] do usuário [111]
emitindo roomData para o socket [e1Uz1zmhYoIcFJKxAAAD] do usuário [111]
emitindo RoomData para todos os sockets do usuário [122]
emitindo roomData para o socket [idBN8EgKLTaRM98AAAAB] do usuário [122]
Pegando player do usuário [122] na sala [11]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 122);
Usuário [122] com socket [idBN8EgKLTaRM98AAAAB] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 131
retornando a sala do jogador [Pim3] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 122 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 122 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "name", "createdAt", "updatedAt" FROM "users" AS "User" WHERE "User"."id" = 122;
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:346
      if (user.sockets.length == 0 && userRoom.state !== "WAITING_FOR_PLAYERS") {
                       ^

TypeError: Cannot read property 'length' of undefined
    at Socket.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:346:24)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [RULxx7vzqG74smIcAAAA]
Conteúdo de handshake da socket [RULxx7vzqG74smIcAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=idBN8EgKLTaRM98AAAAB; connect.sid=s%3AMWZYah0rIdNTvKvsgX5gIjURfKVVNEu8.LTalmgaPQVigbIKezu3Ohiabpgjbq55okv3%2FiFl0hOk"
  },
  "time": "Sun Feb 14 2021 18:29:52 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338192728,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSojE",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSojE"
  }
}
Conteúdo da sessão da socket [RULxx7vzqG74smIcAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:29:52.726Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [RULxx7vzqG74smIcAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 124,
    updatedAt: 2021-02-14T21:29:52.792Z,
    createdAt: 2021-02-14T21:29:52.792Z,
    name: null
  },
  _previousDataValues: {
    id: 124,
    name: null,
    createdAt: 2021-02-14T21:29:52.792Z,
    updatedAt: 2021-02-14T21:29:52.792Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 124
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [RULxx7vzqG74smIcAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:29:52.726Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 124
}
Ligando o usuário [124] ao socket [132]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 124 AND (("Socket"."id" = 132)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (132)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 124;
Usuário [124] ligado ao socket [132], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [124]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 124 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 124 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [nvpSX2sZf8O2aVKLAAAB]
Conteúdo de handshake da socket [nvpSX2sZf8O2aVKLAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_666",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AJ8lVyScN4AhkiX9hoVDKEDKbqSfCs7qc.LFmQlhs8fnJinfaFN0pLFMuKVySdFGzo4sCH6SnLjhc; io=5YvmcNkhwakJNJP9AAAC"
  },
  "time": "Sun Feb 14 2021 18:29:54 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338194077,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSp2R",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSp2R"
  }
}
Conteúdo da sessão da socket [nvpSX2sZf8O2aVKLAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:29:54.077Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [nvpSX2sZf8O2aVKLAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 125,
    updatedAt: 2021-02-14T21:29:54.086Z,
    createdAt: 2021-02-14T21:29:54.086Z,
    name: null
  },
  _previousDataValues: {
    id: 125,
    name: null,
    createdAt: 2021-02-14T21:29:54.086Z,
    updatedAt: 2021-02-14T21:29:54.086Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 125
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [nvpSX2sZf8O2aVKLAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:29:54.077Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 125
}
Ligando o usuário [125] ao socket [133]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 125 AND (("Socket"."id" = 133)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (133)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 125;
Usuário [125] ligado ao socket [133], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [125]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 125 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 125 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [7k2cpsQtbcHa7sXtAAAC]
Conteúdo de handshake da socket [7k2cpsQtbcHa7sXtAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=RULxx7vzqG74smIcAAAA; connect.sid=s%3A7tPlBCHAaQkwUyWEg91Yb-ZVsmnh4FQP.SZ0AVe4ERjr6R2pdseI3zKp9Vik8XQRjGaJuzoiZF%2F4"
  },
  "time": "Sun Feb 14 2021 18:29:54 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338194106,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSp2u",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSp2u"
  }
}
Conteúdo da sessão da socket [7k2cpsQtbcHa7sXtAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:29:54.106Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [7k2cpsQtbcHa7sXtAAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 126,
    updatedAt: 2021-02-14T21:29:54.110Z,
    createdAt: 2021-02-14T21:29:54.110Z,
    name: null
  },
  _previousDataValues: {
    id: 126,
    name: null,
    createdAt: 2021-02-14T21:29:54.110Z,
    updatedAt: 2021-02-14T21:29:54.110Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 126
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [7k2cpsQtbcHa7sXtAAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:29:54.106Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 126
}
Ligando o usuário [126] ao socket [134]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 126 AND (("Socket"."id" = 134)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (134)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 126;
Usuário [126] ligado ao socket [134], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [126]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 126 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 126 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [126] tentando entrar com nome [Pim3] na sala com nome [neo_sala_666]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 126 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 126 ) ON "Room"."id" = "players"."roomId";
Usuário [126] trocou o nome de [null] para [Pim3]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_666]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_666' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 11,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_666',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:23:36.085Z,
    updatedAt: 2021-02-14T21:23:36.085Z,
    hostId: 110,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 11,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_666',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:23:36.085Z,
    updatedAt: 2021-02-14T21:23:36.085Z,
    hostId: 110,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_666' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 110,
      name: 'Pim',
      createdAt: 2021-02-14T21:23:11.961Z,
      updatedAt: 2021-02-14T21:23:36.060Z
    },
    _previousDataValues: {
      id: 110,
      name: 'Pim',
      createdAt: 2021-02-14T21:23:11.961Z,
      updatedAt: 2021-02-14T21:23:36.060Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_666] que o usuário [126] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 126);
Tentando adicionar usuário [Pim3] na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Pim3' WHERE "RoomPlayer"."roomId" = 11;
usuário [Pim3] tentando entrar na sala [neo_sala_666] com nome já existente.
Não foi possivel entrar na sala [neo_sala_666]: [esse nome de usuário já existe na sala!]
Usuário [126] tentando entrar com nome [Pim4] na sala com nome [neo_sala_666]
retornando a sala do jogador [Pim3] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 126 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 126 ) ON "Room"."id" = "players"."roomId";
Usuário [126] trocou o nome de [Pim3] para [Pim4]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [neo_sala_666]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_666' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 11,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_666',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:23:36.085Z,
    updatedAt: 2021-02-14T21:23:36.085Z,
    hostId: 110,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 11,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_666',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:23:36.085Z,
    updatedAt: 2021-02-14T21:23:36.085Z,
    hostId: 110,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_666' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 110,
      name: 'Pim',
      createdAt: 2021-02-14T21:23:11.961Z,
      updatedAt: 2021-02-14T21:23:36.060Z
    },
    _previousDataValues: {
      id: 110,
      name: 'Pim',
      createdAt: 2021-02-14T21:23:11.961Z,
      updatedAt: 2021-02-14T21:23:36.060Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_666] que o usuário [126] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 126);
Tentando adicionar usuário [Pim4] na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Pim4' WHERE "RoomPlayer"."roomId" = 11;
Adicionando usuário [126] à sala [neo_sala_666]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_666
Adicionando usuário [126] para a sala [neo_sala_666] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 11;
Enviando mensagem do sistema [Pim4 tá na área!] para a sala [neo_sala_666]
Emitindo roomData para os sockets conectados na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 11;
emitindo RoomData para todos os sockets do usuário [110]
emitindo roomData para o socket [bMUvExKK0wxqbgE5AAAB] do usuário [110]
emitindo RoomData para todos os sockets do usuário [111]
emitindo roomData para o socket [nD0kqL1UgMU4epUDAAAC] do usuário [111]
emitindo roomData para o socket [e1Uz1zmhYoIcFJKxAAAD] do usuário [111]
emitindo RoomData para todos os sockets do usuário [126]
emitindo roomData para o socket [7k2cpsQtbcHa7sXtAAAC] do usuário [126]
emitindo RoomData para todos os sockets do usuário [122]
Pegando player do usuário [126] na sala [11]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 126);
Usuário [126] com socket [7k2cpsQtbcHa7sXtAAAC] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 134
retornando a sala do jogador [Pim4] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 126 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 126 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 126;
Enviando mensagem do sistema [Pim4 meteu o pé.] para a sala [neo_sala_666]
Emitindo roomData para os sockets conectados na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 126);
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 11;
checando se o jogador atual está na última posição da fila.
jogador atual na última posição. Alterando o currentPlayerIndex para 0.
removendo roomPlayer de id [48] da sala [neo_sala_666]
Executing (default): UPDATE "roomPlayers" SET "roomId"=$1,"updatedAt"=$2 WHERE "roomId" = $3 AND "id" IN (48)
emitindo RoomData para todos os sockets do usuário [110]
emitindo roomData para o socket [bMUvExKK0wxqbgE5AAAB] do usuário [110]
emitindo RoomData para todos os sockets do usuário [111]
emitindo roomData para o socket [nD0kqL1UgMU4epUDAAAC] do usuário [111]
emitindo roomData para o socket [e1Uz1zmhYoIcFJKxAAAD] do usuário [111]
emitindo RoomData para todos os sockets do usuário [122]
emitindo RoomData para todos os sockets do usuário [126]
Agora temos [1] usuários na sala
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [VhWMstbB_4WewOlIAAAD]
Conteúdo de handshake da socket [VhWMstbB_4WewOlIAAAD]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=7k2cpsQtbcHa7sXtAAAC; connect.sid=s%3A7tPlBCHAaQkwUyWEg91Yb-ZVsmnh4FQP.SZ0AVe4ERjr6R2pdseI3zKp9Vik8XQRjGaJuzoiZF%2F4"
  },
  "time": "Sun Feb 14 2021 18:30:09 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338209427,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSsoG",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSsoG"
  }
}
Conteúdo da sessão da socket [VhWMstbB_4WewOlIAAAD]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:30:09.427Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 126
}
Executing (default): SELECT "User"."id", "User"."name", "User"."createdAt", "User"."updatedAt", "sockets"."id" AS "sockets.id", "sockets"."socketId" AS "sockets.socketId", "sockets"."createdAt" AS "sockets.createdAt", "sockets"."updatedAt" AS "sockets.updatedAt", "sockets"."userId" AS "sockets.userId", "sockets"."roomId" AS "sockets.roomId" FROM "users" AS "User" LEFT OUTER JOIN "sockets" AS "sockets" ON "User"."id" = "sockets"."userId" WHERE "User"."id" = 126;
Detectei o usuário com id [126] para a socket com id [VhWMstbB_4WewOlIAAAD]
retornando a sala do jogador [Pim4] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 126 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 126 ) ON "Room"."id" = "players"."roomId";
Ligando o usuário [126] ao socket [135]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 126 AND (("Socket"."id" = 135)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (135)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 126;
Usuário [126] ligado ao socket [135], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [126]
retornando a sala do jogador [Pim4] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 126 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 126 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
Usuário [126] tentando entrar com nome [Pim4] na sala com nome [neo_sala_666]
retornando a sala do jogador [Pim4] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 126 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 126 ) ON "Room"."id" = "players"."roomId";
Usuário [126] trocou o nome de [Pim4] para [Pim4]
Buscando uma sala com nome [neo_sala_666]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'neo_sala_666' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 11,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_666',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:23:36.085Z,
    updatedAt: 2021-02-14T21:23:36.085Z,
    hostId: 110,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 11,
    state: 'WAITING_FOR_PLAYERS',
    name: 'neo_sala_666',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:23:36.085Z,
    updatedAt: 2021-02-14T21:23:36.085Z,
    hostId: 110,
    players: [ [RoomPlayer], [RoomPlayer], [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'neo_sala_666' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    },
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 110,
      name: 'Pim',
      createdAt: 2021-02-14T21:23:11.961Z,
      updatedAt: 2021-02-14T21:23:36.060Z
    },
    _previousDataValues: {
      id: 110,
      name: 'Pim',
      createdAt: 2021-02-14T21:23:11.961Z,
      updatedAt: 2021-02-14T21:23:36.060Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: [Object],
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [neo_sala_666] que o usuário [126] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 126);
Tentando adicionar usuário [Pim4] na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Pim4' WHERE "RoomPlayer"."roomId" = 11;
Adicionando usuário [126] à sala [neo_sala_666]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: neo_sala_666
Adicionando usuário [126] para a sala [neo_sala_666] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 11;
Enviando mensagem do sistema [Pim4 tá na área!] para a sala [neo_sala_666]
Emitindo roomData para os sockets conectados na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 11;
emitindo RoomData para todos os sockets do usuário [110]
emitindo roomData para o socket [bMUvExKK0wxqbgE5AAAB] do usuário [110]
emitindo RoomData para todos os sockets do usuário [111]
emitindo roomData para o socket [nD0kqL1UgMU4epUDAAAC] do usuário [111]
emitindo roomData para o socket [e1Uz1zmhYoIcFJKxAAAD] do usuário [111]
emitindo RoomData para todos os sockets do usuário [126]
emitindo roomData para o socket [VhWMstbB_4WewOlIAAAD] do usuário [126]
emitindo RoomData para todos os sockets do usuário [122]
Pegando player do usuário [126] na sala [11]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 126);
Usuário [126] com socket [VhWMstbB_4WewOlIAAAD] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 135
retornando a sala do jogador [Pim4] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 126 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 126 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 126;
Enviando mensagem do sistema [Pim4 meteu o pé.] para a sala [neo_sala_666]
Emitindo roomData para os sockets conectados na sala [neo_sala_666]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 11 AND "RoomPlayer"."userId" = 126);
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 11;
checando se o jogador atual está na última posição da fila.
jogador atual na última posição. Alterando o currentPlayerIndex para 0.
removendo roomPlayer de id [49] da sala [neo_sala_666]
Executing (default): UPDATE "roomPlayers" SET "roomId"=$1,"updatedAt"=$2 WHERE "roomId" = $3 AND "id" IN (49)
emitindo RoomData para todos os sockets do usuário [110]
emitindo roomData para o socket [bMUvExKK0wxqbgE5AAAB] do usuário [110]
emitindo RoomData para todos os sockets do usuário [111]
emitindo roomData para o socket [nD0kqL1UgMU4epUDAAAC] do usuário [111]
emitindo roomData para o socket [e1Uz1zmhYoIcFJKxAAAD] do usuário [111]
emitindo RoomData para todos os sockets do usuário [122]
emitindo RoomData para todos os sockets do usuário [126]
Agora temos [1] usuários na sala
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [6mm4DFaf6lIiNAdbAAAE]
Conteúdo de handshake da socket [6mm4DFaf6lIiNAdbAAAE]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=VhWMstbB_4WewOlIAAAD; connect.sid=s%3A7tPlBCHAaQkwUyWEg91Yb-ZVsmnh4FQP.SZ0AVe4ERjr6R2pdseI3zKp9Vik8XQRjGaJuzoiZF%2F4"
  },
  "time": "Sun Feb 14 2021 18:30:31 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338231147,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYSy5g",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYSy5g"
  }
}
Conteúdo da sessão da socket [6mm4DFaf6lIiNAdbAAAE]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:30:31.147Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 126
}
Executing (default): SELECT "User"."id", "User"."name", "User"."createdAt", "User"."updatedAt", "sockets"."id" AS "sockets.id", "sockets"."socketId" AS "sockets.socketId", "sockets"."createdAt" AS "sockets.createdAt", "sockets"."updatedAt" AS "sockets.updatedAt", "sockets"."userId" AS "sockets.userId", "sockets"."roomId" AS "sockets.roomId" FROM "users" AS "User" LEFT OUTER JOIN "sockets" AS "sockets" ON "User"."id" = "sockets"."userId" WHERE "User"."id" = 126;
Detectei o usuário com id [126] para a socket com id [6mm4DFaf6lIiNAdbAAAE]
retornando a sala do jogador [Pim4] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 126 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 126 ) ON "Room"."id" = "players"."roomId";
Ligando o usuário [126] ao socket [136]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 126 AND (("Socket"."id" = 136)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (136)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 126;
Usuário [126] ligado ao socket [136], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [126]
retornando a sala do jogador [Pim4] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 126 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 126 ) ON "Room"."id" = "players"."roomId";
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [hWiB7eeDk2t7_ZJlAAAA]
Conteúdo de handshake da socket [hWiB7eeDk2t7_ZJlAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_666",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AWZy657EKg8dqkEEzkx4OPUn02d6HIv71.LM%2FCbfTMj3DvOoRUm%2F7Rd52JSEQDX9UagG0R92hPyFg; io=nvpSX2sZf8O2aVKLAAAB"
  },
  "time": "Sun Feb 14 2021 18:33:36 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338416849,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYTfQk",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYTfQk"
  }
}
Conteúdo da sessão da socket [hWiB7eeDk2t7_ZJlAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:33:36.846Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [hWiB7eeDk2t7_ZJlAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 127,
    updatedAt: 2021-02-14T21:33:36.918Z,
    createdAt: 2021-02-14T21:33:36.918Z,
    name: null
  },
  _previousDataValues: {
    id: 127,
    name: null,
    createdAt: 2021-02-14T21:33:36.918Z,
    updatedAt: 2021-02-14T21:33:36.918Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 127
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [hWiB7eeDk2t7_ZJlAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:33:36.846Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 127
}
Ligando o usuário [127] ao socket [137]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 127 AND (("Socket"."id" = 137)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (137)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 127;
Usuário [127] ligado ao socket [137], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [127]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 127 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 127 ) ON "Room"."id" = "players"."roomId";
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:81
  console.log("sala [%s] encontrada", userRoom.name)
                                               ^

TypeError: Cannot read property 'name' of null
    at Namespace.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:81:48)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [x4uvskolgZBXP6gSAAAA]
Conteúdo de handshake da socket [x4uvskolgZBXP6gSAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=6mm4DFaf6lIiNAdbAAAE; connect.sid=s%3A7tPlBCHAaQkwUyWEg91Yb-ZVsmnh4FQP.SZ0AVe4ERjr6R2pdseI3zKp9Vik8XQRjGaJuzoiZF%2F4"
  },
  "time": "Sun Feb 14 2021 18:34:24 GMT-0300 (Brasilia Standard Time)",
  "address": "::1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338464393,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYTr1z",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYTr1z"
  }
}
Conteúdo da sessão da socket [x4uvskolgZBXP6gSAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:34:24.391Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [x4uvskolgZBXP6gSAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 128,
    updatedAt: 2021-02-14T21:34:24.449Z,
    createdAt: 2021-02-14T21:34:24.449Z,
    name: null
  },
  _previousDataValues: {
    id: 128,
    name: null,
    createdAt: 2021-02-14T21:34:24.449Z,
    updatedAt: 2021-02-14T21:34:24.449Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 128
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [x4uvskolgZBXP6gSAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:34:24.391Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 128
}
Ligando o usuário [128] ao socket [138]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 128 AND (("Socket"."id" = 138)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (138)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 128;
Usuário [128] ligado ao socket [138], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [128]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 128 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 128 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [1lPcWPUQ8WFVWqWrAAAB]
Conteúdo de handshake da socket [1lPcWPUQ8WFVWqWrAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=x4uvskolgZBXP6gSAAAA; connect.sid=s%3A3Ir-t-qHwKH5WtO4wTDGY3D0cQi-oj5F.1knTtUs1o%2FMibtvbn2XiVYWNFQCH8uMQ0YBzvAA%2Bol0"
  },
  "time": "Sun Feb 14 2021 18:34:27 GMT-0300 (Brasilia Standard Time)",
  "address": "::1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338467511,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYTron",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYTron"
  }
}
Conteúdo da sessão da socket [1lPcWPUQ8WFVWqWrAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:34:27.511Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [1lPcWPUQ8WFVWqWrAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 129,
    updatedAt: 2021-02-14T21:34:27.528Z,
    createdAt: 2021-02-14T21:34:27.528Z,
    name: null
  },
  _previousDataValues: {
    id: 129,
    name: null,
    createdAt: 2021-02-14T21:34:27.528Z,
    updatedAt: 2021-02-14T21:34:27.528Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 129
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [1lPcWPUQ8WFVWqWrAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:34:27.511Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 129
}
Ligando o usuário [129] ao socket [139]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 129 AND (("Socket"."id" = 139)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (139)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 129;
Usuário [129] ligado ao socket [139], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [129]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 129 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 129 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [oOtqXZj4ENPDelIyAAAC]
Conteúdo de handshake da socket [oOtqXZj4ENPDelIyAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=neo_sala_666",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AS3WMD-0TMHlQzr7Pr89kl0hpULjvs9Pp.hhxdlSOVCbvCMyw6qe1aLBbGCgs0p3NN0shGInxOEfg; io=hWiB7eeDk2t7_ZJlAAAA"
  },
  "time": "Sun Feb 14 2021 18:34:28 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338468419,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYTs0w",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYTs0w"
  }
}
Conteúdo da sessão da socket [oOtqXZj4ENPDelIyAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:34:28.418Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [oOtqXZj4ENPDelIyAAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 130,
    updatedAt: 2021-02-14T21:34:28.434Z,
    createdAt: 2021-02-14T21:34:28.434Z,
    name: null
  },
  _previousDataValues: {
    id: 130,
    name: null,
    createdAt: 2021-02-14T21:34:28.434Z,
    updatedAt: 2021-02-14T21:34:28.434Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 130
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [oOtqXZj4ENPDelIyAAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:34:28.418Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 130
}
Ligando o usuário [130] ao socket [140]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 130 AND (("Socket"."id" = 140)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (140)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 130;
Usuário [130] ligado ao socket [140], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [130]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 130 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 130 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [130] com socket [oOtqXZj4ENPDelIyAAAC] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 140
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 130 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 130 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 130;
Usuário [129] com socket [1lPcWPUQ8WFVWqWrAAAB] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 139
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 129 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 129 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 129;
Usuário [128] com socket [x4uvskolgZBXP6gSAAAA] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 138
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 128 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 128 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 128;
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [NZKiBKkQjpeQeB0PAAAD]
Conteúdo de handshake da socket [NZKiBKkQjpeQeB0PAAAD]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AWmdI8XHCW6t1NQ9TUF-94QjDQSp9GZa3.yoO%2BSzZS5ecSsnNamp7lYLIkAgMcqOJWbxHQjsY%2BvPE; io=oOtqXZj4ENPDelIyAAAC"
  },
  "time": "Sun Feb 14 2021 18:36:47 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338607211,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYUNvf",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYUNvf"
  }
}
Conteúdo da sessão da socket [NZKiBKkQjpeQeB0PAAAD]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:36:47.211Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [NZKiBKkQjpeQeB0PAAAD] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 131,
    updatedAt: 2021-02-14T21:36:47.220Z,
    createdAt: 2021-02-14T21:36:47.220Z,
    name: null
  },
  _previousDataValues: {
    id: 131,
    name: null,
    createdAt: 2021-02-14T21:36:47.220Z,
    updatedAt: 2021-02-14T21:36:47.220Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 131
Usuário adicionado, agora temos [4] usuário(s)
Salvando sessao da socket [NZKiBKkQjpeQeB0PAAAD]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:36:47.211Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 131
}
Ligando o usuário [131] ao socket [141]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 131 AND (("Socket"."id" = 141)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (141)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 131;
Usuário [131] ligado ao socket [141], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [131]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 131 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 131 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [131] tentando entrar com nome [Pi] na sala com nome [sa]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 131 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 131 ) ON "Room"."id" = "players"."roomId";
Usuário [131] trocou o nome de [null] para [Pi]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [sa]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'sa' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
null
A sala que o usuário tentou entrar [sa] não existe ainda, vamos criar uma para ele
Criando uma sala com nome [sa] para o hostPlayer [Pi]
Buscando uma sala com nome [sa]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'sa' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Procurando uma sala existente [Sala disponível]
Executing (default): INSERT INTO "rooms" ("id","state","name","turn","currentPlayerIndex","prompt","selectedCardCount","victory","votingCardsTurn","winner","minimumPlayersToStart","minimumCardsToStart","selectedDecksIds","deck","morto","results","createdAt","updatedAt","hostId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18) RETURNING *;
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
[]
Sala criada com nome [sa] e host player [Pi]
Buscando uma sala com nome [sa]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'sa' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Sala [sa] criada para o usuário [131]
Sala atual é: sa
Adicionando usuário [131] para a sala [sa] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 12;
Enviando mensagem do sistema [Pi tá na área!] para a sala [sa]
Emitindo roomData para os sockets conectados na sala [sa]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 12;
emitindo RoomData para todos os sockets do usuário [131]
emitindo roomData para o socket [NZKiBKkQjpeQeB0PAAAD] do usuário [131]
Pegando player do usuário [131] na sala [12]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 12 AND "RoomPlayer"."userId" = 131);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [csIj5nlIhORaxmZoAAAE]
Conteúdo de handshake da socket [csIj5nlIhORaxmZoAAAE]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/"
  },
  "time": "Sun Feb 14 2021 18:36:58 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338618950,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYUQn4",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYUQn4"
  }
}
Conteúdo da sessão da socket [csIj5nlIhORaxmZoAAAE]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:36:58.950Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [csIj5nlIhORaxmZoAAAE] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 132,
    updatedAt: 2021-02-14T21:36:58.958Z,
    createdAt: 2021-02-14T21:36:58.958Z,
    name: null
  },
  _previousDataValues: {
    id: 132,
    name: null,
    createdAt: 2021-02-14T21:36:58.958Z,
    updatedAt: 2021-02-14T21:36:58.958Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 132
Usuário adicionado, agora temos [5] usuário(s)
Salvando sessao da socket [csIj5nlIhORaxmZoAAAE]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:36:58.950Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 132
}
Ligando o usuário [132] ao socket [142]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 132 AND (("Socket"."id" = 142)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (142)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 132;
Usuário [132] ligado ao socket [142], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [132]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 132 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 132 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [132] tentando entrar com nome [Pi2] na sala com nome [sa]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 132 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 132 ) ON "Room"."id" = "players"."roomId";
Usuário [132] trocou o nome de [null] para [Pi2]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [sa]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'sa' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 12,
    state: 'WAITING_FOR_PLAYERS',
    name: 'sa',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:36:54.308Z,
    updatedAt: 2021-02-14T21:36:54.308Z,
    hostId: 131,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 12,
    state: 'WAITING_FOR_PLAYERS',
    name: 'sa',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:36:54.308Z,
    updatedAt: 2021-02-14T21:36:54.308Z,
    hostId: 131,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'sa' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 131,
      name: 'Pi',
      createdAt: 2021-02-14T21:36:47.220Z,
      updatedAt: 2021-02-14T21:36:54.289Z
    },
    _previousDataValues: {
      id: 131,
      name: 'Pi',
      createdAt: 2021-02-14T21:36:47.220Z,
      updatedAt: 2021-02-14T21:36:54.289Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [sa] que o usuário [132] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 12 AND "RoomPlayer"."userId" = 132);
Tentando adicionar usuário [Pi2] na sala [sa]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Pi2' WHERE "RoomPlayer"."roomId" = 12;
Adicionando usuário [132] à sala [sa]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: sa
Adicionando usuário [132] para a sala [sa] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 12;
Enviando mensagem do sistema [Pi2 tá na área!] para a sala [sa]
Emitindo roomData para os sockets conectados na sala [sa]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 12;
emitindo RoomData para todos os sockets do usuário [131]
emitindo roomData para o socket [NZKiBKkQjpeQeB0PAAAD] do usuário [131]
emitindo RoomData para todos os sockets do usuário [132]
emitindo roomData para o socket [csIj5nlIhORaxmZoAAAE] do usuário [132]
Pegando player do usuário [132] na sala [12]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 12 AND "RoomPlayer"."userId" = 132);
Usuário [131] com socket [NZKiBKkQjpeQeB0PAAAD] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 141
retornando a sala do jogador [Pi] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 131 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 131 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 131;
Enviando mensagem do sistema [Pi meteu o pé.] para a sala [sa]
Emitindo roomData para os sockets conectados na sala [sa]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 12 AND "RoomPlayer"."userId" = 131);
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 12;
checando se o jogador atual está na última posição da fila.
jogador atual na última posição. Alterando o currentPlayerIndex para 0.
removendo roomPlayer de id [50] da sala [sa]
Executing (default): UPDATE "roomPlayers" SET "roomId"=$1,"updatedAt"=$2 WHERE "roomId" = $3 AND "id" IN (50)
emitindo RoomData para todos os sockets do usuário [132]
emitindo roomData para o socket [csIj5nlIhORaxmZoAAAE] do usuário [132]
emitindo RoomData para todos os sockets do usuário [131]
Agora temos [1] usuários na sala
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [e3mbSRuqSAcF-KdoAAAF]
Conteúdo de handshake da socket [e3mbSRuqSAcF-KdoAAAF]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AWmdI8XHCW6t1NQ9TUF-94QjDQSp9GZa3.yoO%2BSzZS5ecSsnNamp7lYLIkAgMcqOJWbxHQjsY%2BvPE; io=NZKiBKkQjpeQeB0PAAAD"
  },
  "time": "Sun Feb 14 2021 18:37:15 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338635594,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYUUr9",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYUUr9"
  }
}
Conteúdo da sessão da socket [e3mbSRuqSAcF-KdoAAAF]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:37:15.594Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 131
}
Executing (default): SELECT "User"."id", "User"."name", "User"."createdAt", "User"."updatedAt", "sockets"."id" AS "sockets.id", "sockets"."socketId" AS "sockets.socketId", "sockets"."createdAt" AS "sockets.createdAt", "sockets"."updatedAt" AS "sockets.updatedAt", "sockets"."userId" AS "sockets.userId", "sockets"."roomId" AS "sockets.roomId" FROM "users" AS "User" LEFT OUTER JOIN "sockets" AS "sockets" ON "User"."id" = "sockets"."userId" WHERE "User"."id" = 131;
Detectei o usuário com id [131] para a socket com id [e3mbSRuqSAcF-KdoAAAF]
retornando a sala do jogador [Pi] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 131 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 131 ) ON "Room"."id" = "players"."roomId";
Ligando o usuário [131] ao socket [143]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 131 AND (("Socket"."id" = 143)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (143)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 131;
Usuário [131] ligado ao socket [143], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [131]
retornando a sala do jogador [Pi] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 131 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 131 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [131] tentando entrar com nome [Pi] na sala com nome [sa]
retornando a sala do jogador [Pi] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 131 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 131 ) ON "Room"."id" = "players"."roomId";
Usuário [131] trocou o nome de [Pi] para [Pi]
Buscando uma sala com nome [sa]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'sa' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 12,
    state: 'WAITING_FOR_PLAYERS',
    name: 'sa',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:36:54.308Z,
    updatedAt: 2021-02-14T21:36:54.308Z,
    hostId: 131,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 12,
    state: 'WAITING_FOR_PLAYERS',
    name: 'sa',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:36:54.308Z,
    updatedAt: 2021-02-14T21:36:54.308Z,
    hostId: 131,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'sa' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 131,
      name: 'Pi',
      createdAt: 2021-02-14T21:36:47.220Z,
      updatedAt: 2021-02-14T21:36:54.289Z
    },
    _previousDataValues: {
      id: 131,
      name: 'Pi',
      createdAt: 2021-02-14T21:36:47.220Z,
      updatedAt: 2021-02-14T21:36:54.289Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: [Object],
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [sa] que o usuário [131] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 12 AND "RoomPlayer"."userId" = 131);
Tentando adicionar usuário [Pi] na sala [sa]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'Pi' WHERE "RoomPlayer"."roomId" = 12;
Adicionando usuário [131] à sala [sa]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: sa
Adicionando usuário [131] para a sala [sa] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 12;
Enviando mensagem do sistema [Pi tá na área!] para a sala [sa]
Emitindo roomData para os sockets conectados na sala [sa]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 12;
emitindo RoomData para todos os sockets do usuário [132]
emitindo roomData para o socket [csIj5nlIhORaxmZoAAAE] do usuário [132]
emitindo RoomData para todos os sockets do usuário [131]
emitindo roomData para o socket [e3mbSRuqSAcF-KdoAAAF] do usuário [131]
Pegando player do usuário [131] na sala [12]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 12 AND "RoomPlayer"."userId" = 131);
retornando a sala do jogador [Pi] se ele estiver em uma
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:187
    if (userRoom.host.id != user.id) {
                      ^

TypeError: Cannot read property 'id' of undefined
    at Socket.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:187:23)
    at Socket.emit (node:events:378:20)
    at /home/sandesvitor/Projeckts/Kah-Dix-v2/server/node_modules/socket.io/lib/socket.js:528:12
    at processTicksAndRejections (node:internal/process/task_queues:76:11)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [3yRPKBlyOtTtZu8bAAAA]
Conteúdo de handshake da socket [3yRPKBlyOtTtZu8bAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=csIj5nlIhORaxmZoAAAE; connect.sid=s%3AECD0I9hpEttiDd0b4UfWrTuk1wiEc5_j.T8JAa7bwyM0W2FYKRbkdh%2BuTmyr38nJFlc5nYfxouJ0"
  },
  "time": "Sun Feb 14 2021 18:39:53 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338793436,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYV5N3",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYV5N3"
  }
}
Conteúdo da sessão da socket [3yRPKBlyOtTtZu8bAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:39:53.432Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [3yRPKBlyOtTtZu8bAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 133,
    updatedAt: 2021-02-14T21:39:53.504Z,
    createdAt: 2021-02-14T21:39:53.504Z,
    name: null
  },
  _previousDataValues: {
    id: 133,
    name: null,
    createdAt: 2021-02-14T21:39:53.504Z,
    updatedAt: 2021-02-14T21:39:53.504Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 133
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [3yRPKBlyOtTtZu8bAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:39:53.432Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 133
}
Ligando o usuário [133] ao socket [144]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 133 AND (("Socket"."id" = 144)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (144)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 133;
Usuário [133] ligado ao socket [144], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [133]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 133 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 133 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [ujJgXzqSx-eUeMUnAAAB]
Conteúdo de handshake da socket [ujJgXzqSx-eUeMUnAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AWmdI8XHCW6t1NQ9TUF-94QjDQSp9GZa3.yoO%2BSzZS5ecSsnNamp7lYLIkAgMcqOJWbxHQjsY%2BvPE; io=e3mbSRuqSAcF-KdoAAAF"
  },
  "time": "Sun Feb 14 2021 18:39:54 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338794941,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYV5kw",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYV5kw"
  }
}
Conteúdo da sessão da socket [ujJgXzqSx-eUeMUnAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:39:54.941Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [ujJgXzqSx-eUeMUnAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 134,
    updatedAt: 2021-02-14T21:39:54.948Z,
    createdAt: 2021-02-14T21:39:54.948Z,
    name: null
  },
  _previousDataValues: {
    id: 134,
    name: null,
    createdAt: 2021-02-14T21:39:54.948Z,
    updatedAt: 2021-02-14T21:39:54.948Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 134
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [ujJgXzqSx-eUeMUnAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:39:54.941Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 134
}
Ligando o usuário [134] ao socket [145]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 134 AND (("Socket"."id" = 145)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (145)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 134;
Usuário [134] ligado ao socket [145], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [134]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 134 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 134 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [39yQM-7wmZWPb5U0AAAA]
Conteúdo de handshake da socket [39yQM-7wmZWPb5U0AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AY5uzzhOwHIjLLW0kIwuUgsZ59mlYGJq6.TAP3S6DDO6o9FV7x%2FO5zM3tD5NavcsS%2BT932NjgNL7M; io=ujJgXzqSx-eUeMUnAAAB"
  },
  "time": "Sun Feb 14 2021 18:41:25 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338885475,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYVRr8",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYVRr8"
  }
}
Conteúdo da sessão da socket [39yQM-7wmZWPb5U0AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:41:25.472Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [39yQM-7wmZWPb5U0AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 135,
    updatedAt: 2021-02-14T21:41:25.537Z,
    createdAt: 2021-02-14T21:41:25.537Z,
    name: null
  },
  _previousDataValues: {
    id: 135,
    name: null,
    createdAt: 2021-02-14T21:41:25.537Z,
    updatedAt: 2021-02-14T21:41:25.537Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 135
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [39yQM-7wmZWPb5U0AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:41:25.472Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 135
}
Ligando o usuário [135] ao socket [146]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 135 AND (("Socket"."id" = 146)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (146)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 135;
Usuário [135] ligado ao socket [146], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [135]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 135 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 135 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [JC7MP9PdSawL9Me4AAAB]
Conteúdo de handshake da socket [JC7MP9PdSawL9Me4AAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=3yRPKBlyOtTtZu8bAAAA; connect.sid=s%3ANhdRKy6vQO49Cn-rIuaoNIvK3cWHVoWQ.bmqZv%2BK%2Bbgd82QiSNA9rrciVBsTOyZsuWpHSsXPfu34"
  },
  "time": "Sun Feb 14 2021 18:41:25 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338885617,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYVRtk",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYVRtk"
  }
}
Conteúdo da sessão da socket [JC7MP9PdSawL9Me4AAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:41:25.617Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [JC7MP9PdSawL9Me4AAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 136,
    updatedAt: 2021-02-14T21:41:25.623Z,
    createdAt: 2021-02-14T21:41:25.623Z,
    name: null
  },
  _previousDataValues: {
    id: 136,
    name: null,
    createdAt: 2021-02-14T21:41:25.623Z,
    updatedAt: 2021-02-14T21:41:25.623Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 136
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [JC7MP9PdSawL9Me4AAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:41:25.617Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 136
}
Ligando o usuário [136] ao socket [147]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 136 AND (("Socket"."id" = 147)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (147)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 136;
Usuário [136] ligado ao socket [147], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [136]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 136 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 136 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [Sc26OejUv_NtV8f6AAAA]
Conteúdo de handshake da socket [Sc26OejUv_NtV8f6AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AbbQKWbxjl8cBMfTqiuMGp-0Mh8Fn4X0x.WvGvDSLi33D1%2FlqGAfOmYfOr6Y6Kv0DM7qz1ONt8bK0; io=39yQM-7wmZWPb5U0AAAA"
  },
  "time": "Sun Feb 14 2021 18:42:53 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338973947,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYVnRS",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYVnRS"
  }
}
Conteúdo da sessão da socket [Sc26OejUv_NtV8f6AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:42:53.941Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [Sc26OejUv_NtV8f6AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 137,
    updatedAt: 2021-02-14T21:42:54.007Z,
    createdAt: 2021-02-14T21:42:54.007Z,
    name: null
  },
  _previousDataValues: {
    id: 137,
    name: null,
    createdAt: 2021-02-14T21:42:54.007Z,
    updatedAt: 2021-02-14T21:42:54.007Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 137
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [Sc26OejUv_NtV8f6AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:42:53.941Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 137
}
Ligando o usuário [137] ao socket [148]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 137 AND (("Socket"."id" = 148)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (148)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 137;
Usuário [137] ligado ao socket [148], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [137]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 137 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 137 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [KdkH4Fxh0QQVGsbRAAAB]
Conteúdo de handshake da socket [KdkH4Fxh0QQVGsbRAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=JC7MP9PdSawL9Me4AAAB; connect.sid=s%3A2d_AXYX7LGezxl-kpYnSqtTcOG5hFgi6.mle5n1oUmae7KXlFelG0ZPJZWHk3dcx8xj9tKHaJYHM"
  },
  "time": "Sun Feb 14 2021 18:42:54 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613338974360,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYVnYH",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYVnYH"
  }
}
Conteúdo da sessão da socket [KdkH4Fxh0QQVGsbRAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:42:54.359Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [KdkH4Fxh0QQVGsbRAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 138,
    updatedAt: 2021-02-14T21:42:54.374Z,
    createdAt: 2021-02-14T21:42:54.374Z,
    name: null
  },
  _previousDataValues: {
    id: 138,
    name: null,
    createdAt: 2021-02-14T21:42:54.374Z,
    updatedAt: 2021-02-14T21:42:54.374Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 138
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [KdkH4Fxh0QQVGsbRAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:42:54.359Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 138
}
Ligando o usuário [138] ao socket [149]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 138 AND (("Socket"."id" = 149)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (149)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 138;
Usuário [138] ligado ao socket [149], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [138]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 138 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 138 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [_G93DCXVi2phgT7YAAAA]
Conteúdo de handshake da socket [_G93DCXVi2phgT7YAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3ArT3115HrnQ_D9N_JoWZmii-DJYYNwJiZ.gjIaq2sKpxx6ahEcZZzVnV%2FEwEStm6VwWguQO3NSlUI; io=Sc26OejUv_NtV8f6AAAA"
  },
  "time": "Sun Feb 14 2021 18:44:40 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339080293,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYWBPD",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYWBPD"
  }
}
Conteúdo da sessão da socket [_G93DCXVi2phgT7YAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:44:40.290Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [_G93DCXVi2phgT7YAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 139,
    updatedAt: 2021-02-14T21:44:40.351Z,
    createdAt: 2021-02-14T21:44:40.351Z,
    name: null
  },
  _previousDataValues: {
    id: 139,
    name: null,
    createdAt: 2021-02-14T21:44:40.351Z,
    updatedAt: 2021-02-14T21:44:40.351Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 139
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [_G93DCXVi2phgT7YAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:44:40.290Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 139
}
Ligando o usuário [139] ao socket [150]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 139 AND (("Socket"."id" = 150)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (150)
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 139;
[io.on('connect') - Nova socket conectada com id [_GBxmt-7x9zoCiJ2AAAB]
Conteúdo de handshake da socket [_GBxmt-7x9zoCiJ2AAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=KdkH4Fxh0QQVGsbRAAAB; connect.sid=s%3AoCUGnIHpGzvQSJMnrJHtwRZlEUA5Pm9I.2JDAB84L%2Bq%2FouMbKlKKX6au46AyR27oFY4QDy6rD9h4"
  },
  "time": "Sun Feb 14 2021 18:44:40 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339080371,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYWBQj",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYWBQj"
  }
}
Conteúdo da sessão da socket [_GBxmt-7x9zoCiJ2AAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:44:40.371Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [_GBxmt-7x9zoCiJ2AAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
Usuário [139] ligado ao socket [150], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [139]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 139 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 139 ) ON "Room"."id" = "players"."roomId";
User {
  dataValues: {
    id: 140,
    updatedAt: 2021-02-14T21:44:40.385Z,
    createdAt: 2021-02-14T21:44:40.385Z,
    name: null
  },
  _previousDataValues: {
    id: 140,
    name: null,
    createdAt: 2021-02-14T21:44:40.385Z,
    updatedAt: 2021-02-14T21:44:40.385Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 140
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [_GBxmt-7x9zoCiJ2AAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:44:40.371Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 140
}
Ligando o usuário [140] ao socket [151]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 140 AND (("Socket"."id" = 151)));
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (151)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 140;
Usuário [140] ligado ao socket [151], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [140]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 140 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 140 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [QV5z4ttZTxBJk9WiAAAA]
Conteúdo de handshake da socket [QV5z4ttZTxBJk9WiAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AGPtPNmPYBGq1_q7Va6LUoD3TUKtsT7uG.cU3CUgfMv2R%2FhfhGWpui%2BrUGd%2FSn4f9CcNgFO04ZOCQ; io=_G93DCXVi2phgT7YAAAA"
  },
  "time": "Sun Feb 14 2021 18:44:42 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339082412,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYWBwF",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYWBwF"
  }
}
Conteúdo da sessão da socket [QV5z4ttZTxBJk9WiAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:44:42.407Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [QV5z4ttZTxBJk9WiAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 141,
    updatedAt: 2021-02-14T21:44:42.470Z,
    createdAt: 2021-02-14T21:44:42.470Z,
    name: null
  },
  _previousDataValues: {
    id: 141,
    name: null,
    createdAt: 2021-02-14T21:44:42.470Z,
    updatedAt: 2021-02-14T21:44:42.470Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 141
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [QV5z4ttZTxBJk9WiAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:44:42.407Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 141
}
Ligando o usuário [141] ao socket [152]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 141 AND (("Socket"."id" = 152)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (152)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 141;
Usuário [141] ligado ao socket [152], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [141]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 141 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 141 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [OYb9M1DHir_-F1fpAAAB]
Conteúdo de handshake da socket [OYb9M1DHir_-F1fpAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=_GBxmt-7x9zoCiJ2AAAB; connect.sid=s%3APD9KOpjbPXyft7Nfl2WrwJRqvTehgKNT.68ApYnMFcChjbbg52OQUYte74WPX1YZIfdQXuGnarv8"
  },
  "time": "Sun Feb 14 2021 18:44:42 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339082499,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYWBx_",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYWBx_"
  }
}
Conteúdo da sessão da socket [OYb9M1DHir_-F1fpAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:44:42.498Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [OYb9M1DHir_-F1fpAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 142,
    updatedAt: 2021-02-14T21:44:42.508Z,
    createdAt: 2021-02-14T21:44:42.508Z,
    name: null
  },
  _previousDataValues: {
    id: 142,
    name: null,
    createdAt: 2021-02-14T21:44:42.508Z,
    updatedAt: 2021-02-14T21:44:42.508Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 142
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [OYb9M1DHir_-F1fpAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:44:42.498Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 142
}
Ligando o usuário [142] ao socket [153]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 142 AND (("Socket"."id" = 153)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (153)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 142;
Usuário [142] ligado ao socket [153], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [142]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 142 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 142 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [dP8WP7WIAsWQ1erCAAAA]
Conteúdo de handshake da socket [dP8WP7WIAsWQ1erCAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=OYb9M1DHir_-F1fpAAAB; connect.sid=s%3AjlWhfir01VKjGDbXT55JIu9mPH9bXdm4.cWWg7AMWPcqfpErj6%2Fi%2FnF4M%2FQei9CoNmIdZxalJE4Q"
  },
  "time": "Sun Feb 14 2021 18:45:27 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339127647,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYWMy-",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYWMy-"
  }
}
Conteúdo da sessão da socket [dP8WP7WIAsWQ1erCAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:45:27.642Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [dP8WP7WIAsWQ1erCAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 143,
    updatedAt: 2021-02-14T21:45:27.708Z,
    createdAt: 2021-02-14T21:45:27.708Z,
    name: null
  },
  _previousDataValues: {
    id: 143,
    name: null,
    createdAt: 2021-02-14T21:45:27.708Z,
    updatedAt: 2021-02-14T21:45:27.708Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 143
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [dP8WP7WIAsWQ1erCAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:45:27.642Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 143
}
Ligando o usuário [143] ao socket [154]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 143 AND (("Socket"."id" = 154)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (154)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 143;
Usuário [143] ligado ao socket [154], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [143]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 143 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 143 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [j7rdtZ2-09hgz0UQAAAB]
Conteúdo de handshake da socket [j7rdtZ2-09hgz0UQAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3A5vFD8ZVHQZh-5CYgruYDpAQwLID--s3L.OKm68fea3Eu90zw1iSLiosKZ1oRAp0pxVD5BDC4dUZo; io=QV5z4ttZTxBJk9WiAAAA"
  },
  "time": "Sun Feb 14 2021 18:45:27 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339127911,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYWN1X",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYWN1X"
  }
}
Conteúdo da sessão da socket [j7rdtZ2-09hgz0UQAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:45:27.910Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [j7rdtZ2-09hgz0UQAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 144,
    updatedAt: 2021-02-14T21:45:27.924Z,
    createdAt: 2021-02-14T21:45:27.924Z,
    name: null
  },
  _previousDataValues: {
    id: 144,
    name: null,
    createdAt: 2021-02-14T21:45:27.924Z,
    updatedAt: 2021-02-14T21:45:27.924Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 144
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [j7rdtZ2-09hgz0UQAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:45:27.910Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 144
}
Ligando o usuário [144] ao socket [155]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 144 AND (("Socket"."id" = 155)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (155)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 144;
Usuário [144] ligado ao socket [155], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [144]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 144 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 144 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [Jiy7PAqOeh-RKCR7AAAA]
Conteúdo de handshake da socket [Jiy7PAqOeh-RKCR7AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=dP8WP7WIAsWQ1erCAAAA; connect.sid=s%3ASaCUCK3jlqLF1CohW4shmE98kzxL-Ig4.hZPzEqs5Ok0%2FsubGZ2udFNxolsAybVugMYKZuJtZS7Q"
  },
  "time": "Sun Feb 14 2021 18:46:11 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339171825,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYWXlX",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYWXlX"
  }
}
Conteúdo da sessão da socket [Jiy7PAqOeh-RKCR7AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:46:11.822Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [Jiy7PAqOeh-RKCR7AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 145,
    updatedAt: 2021-02-14T21:46:11.886Z,
    createdAt: 2021-02-14T21:46:11.886Z,
    name: null
  },
  _previousDataValues: {
    id: 145,
    name: null,
    createdAt: 2021-02-14T21:46:11.886Z,
    updatedAt: 2021-02-14T21:46:11.886Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 145
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [Jiy7PAqOeh-RKCR7AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:46:11.822Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 145
}
Ligando o usuário [145] ao socket [156]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 145 AND (("Socket"."id" = 156)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (156)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 145;
Usuário [145] ligado ao socket [156], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [145]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 145 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 145 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [Z5U7OgmO_FP6pJSfAAAB]
Conteúdo de handshake da socket [Z5U7OgmO_FP6pJSfAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AcZJ_apXJCKqwlL6WHvY_1v5_wZTkf9Gv.TukVofNYAzqY2bvQ0W7zr53xz8%2Fxm43%2Bv%2FlH9GQGTkI; io=j7rdtZ2-09hgz0UQAAAB"
  },
  "time": "Sun Feb 14 2021 18:46:11 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339171978,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYWXo7",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYWXo7"
  }
}
Conteúdo da sessão da socket [Z5U7OgmO_FP6pJSfAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:46:11.978Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [Z5U7OgmO_FP6pJSfAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 146,
    updatedAt: 2021-02-14T21:46:11.988Z,
    createdAt: 2021-02-14T21:46:11.988Z,
    name: null
  },
  _previousDataValues: {
    id: 146,
    name: null,
    createdAt: 2021-02-14T21:46:11.988Z,
    updatedAt: 2021-02-14T21:46:11.988Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 146
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [Z5U7OgmO_FP6pJSfAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:46:11.978Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 146
}
Ligando o usuário [146] ao socket [157]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 146 AND (("Socket"."id" = 157)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (157)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 146;
Usuário [146] ligado ao socket [157], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [146]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 146 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 146 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [2GnORuPygZ389rv7AAAA]
Conteúdo de handshake da socket [2GnORuPygZ389rv7AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=Jiy7PAqOeh-RKCR7AAAA; connect.sid=s%3At1JdUMnftjRXC04g5KIohG-Xv4TZZ1jc.DYXWEv%2FiSI6bVk7l7XFAL6mySoGfhDgZlDi90NCuB%2BM"
  },
  "time": "Sun Feb 14 2021 18:47:32 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339252830,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYWrXE",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYWrXE"
  }
}
Conteúdo da sessão da socket [2GnORuPygZ389rv7AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:47:32.828Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [2GnORuPygZ389rv7AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 147,
    updatedAt: 2021-02-14T21:47:32.888Z,
    createdAt: 2021-02-14T21:47:32.888Z,
    name: null
  },
  _previousDataValues: {
    id: 147,
    name: null,
    createdAt: 2021-02-14T21:47:32.888Z,
    updatedAt: 2021-02-14T21:47:32.888Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 147
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [2GnORuPygZ389rv7AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:47:32.828Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 147
}
Ligando o usuário [147] ao socket [158]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 147 AND (("Socket"."id" = 158)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (158)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 147;
Usuário [147] ligado ao socket [158], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [147]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 147 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 147 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [7PhPUXdebEeny_SkAAAB]
Conteúdo de handshake da socket [7PhPUXdebEeny_SkAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AKTUbZj4pfc8QIKbqbeycX_65zPH1vJV8.ZMad6VgBx8dTZ%2FMCJ8%2Fxj3ypSJ2pxZRXyfsQIYFr7Ts; io=Z5U7OgmO_FP6pJSfAAAB"
  },
  "time": "Sun Feb 14 2021 18:47:33 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339253248,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYWrdw",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYWrdw"
  }
}
Conteúdo da sessão da socket [7PhPUXdebEeny_SkAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:47:33.248Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [7PhPUXdebEeny_SkAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 148,
    updatedAt: 2021-02-14T21:47:33.264Z,
    createdAt: 2021-02-14T21:47:33.264Z,
    name: null
  },
  _previousDataValues: {
    id: 148,
    name: null,
    createdAt: 2021-02-14T21:47:33.264Z,
    updatedAt: 2021-02-14T21:47:33.264Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 148
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [7PhPUXdebEeny_SkAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:47:33.248Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 148
}
Ligando o usuário [148] ao socket [159]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 148 AND (("Socket"."id" = 159)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (159)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 148;
Usuário [148] ligado ao socket [159], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [148]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 148 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 148 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [c-8_YLGPq3zjvwW_AAAA]
Conteúdo de handshake da socket [c-8_YLGPq3zjvwW_AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=2GnORuPygZ389rv7AAAA; connect.sid=s%3AT3nsII47olT0OKHizUsfY5Y-urnHHlzr.wFDacKqKO%2BNsvJ9tXg9QOUIgSFFhNUx8iVxm9lkt4xQ"
  },
  "time": "Sun Feb 14 2021 18:50:07 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339407366,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYXRFt",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYXRFt"
  }
}
Conteúdo da sessão da socket [c-8_YLGPq3zjvwW_AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:50:07.363Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [c-8_YLGPq3zjvwW_AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 149,
    updatedAt: 2021-02-14T21:50:07.420Z,
    createdAt: 2021-02-14T21:50:07.420Z,
    name: null
  },
  _previousDataValues: {
    id: 149,
    name: null,
    createdAt: 2021-02-14T21:50:07.420Z,
    updatedAt: 2021-02-14T21:50:07.420Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 149
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [c-8_YLGPq3zjvwW_AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:50:07.363Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 149
}
Ligando o usuário [149] ao socket [160]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 149 AND (("Socket"."id" = 160)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (160)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 149;
Usuário [149] ligado ao socket [160], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [149]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 149 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 149 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [d3G4Tb0Q4ebIdAegAAAB]
Conteúdo de handshake da socket [d3G4Tb0Q4ebIdAegAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3A7z2X8BaXElg0f7hMMTo0eC9USRkWw7jA.Hu4svjfbfKF5sq69nPMmtXeuYDw9lkireMLro22qgm8; io=7PhPUXdebEeny_SkAAAB"
  },
  "time": "Sun Feb 14 2021 18:50:07 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339407456,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYXRHU",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYXRHU"
  }
}
Conteúdo da sessão da socket [d3G4Tb0Q4ebIdAegAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:50:07.456Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [d3G4Tb0Q4ebIdAegAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 150,
    updatedAt: 2021-02-14T21:50:07.461Z,
    createdAt: 2021-02-14T21:50:07.461Z,
    name: null
  },
  _previousDataValues: {
    id: 150,
    name: null,
    createdAt: 2021-02-14T21:50:07.461Z,
    updatedAt: 2021-02-14T21:50:07.461Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 150
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [d3G4Tb0Q4ebIdAegAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:50:07.456Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 150
}
Ligando o usuário [150] ao socket [161]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 150 AND (("Socket"."id" = 161)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (161)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 150;
Usuário [150] ligado ao socket [161], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [150]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 150 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 150 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [NwtCWhSZ2faHE3UwAAAA]
Conteúdo de handshake da socket [NwtCWhSZ2faHE3UwAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=c-8_YLGPq3zjvwW_AAAA; connect.sid=s%3ALMMrsnhvCp1YpG_HJWgZfzwDl7Fl_VlP.TsAGJfW%2BgIuACSiakPRCcAPfJ0Q7JTuIbtI7PQgyRC4"
  },
  "time": "Sun Feb 14 2021 18:50:09 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339409689,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYXRpk",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYXRpk"
  }
}
Conteúdo da sessão da socket [NwtCWhSZ2faHE3UwAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:50:09.684Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [NwtCWhSZ2faHE3UwAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 151,
    updatedAt: 2021-02-14T21:50:09.745Z,
    createdAt: 2021-02-14T21:50:09.745Z,
    name: null
  },
  _previousDataValues: {
    id: 151,
    name: null,
    createdAt: 2021-02-14T21:50:09.745Z,
    updatedAt: 2021-02-14T21:50:09.745Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 151
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [NwtCWhSZ2faHE3UwAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:50:09.684Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 151
}
Ligando o usuário [151] ao socket [162]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 151 AND (("Socket"."id" = 162)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (162)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 151;
Usuário [151] ligado ao socket [162], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [151]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 151 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 151 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [t9JKsaXWYOhaivL4AAAB]
Conteúdo de handshake da socket [t9JKsaXWYOhaivL4AAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AyEWHV_w_OkN0j78DXqLccfP8MKxUrW7k.eGxY9ZW%2FgYgzzPqhfZw%2F0vXguugBYgH8gjIJRC%2FY7AI; io=d3G4Tb0Q4ebIdAegAAAB"
  },
  "time": "Sun Feb 14 2021 18:50:10 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339410135,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYXRxG",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYXRxG"
  }
}
Conteúdo da sessão da socket [t9JKsaXWYOhaivL4AAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:50:10.134Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [t9JKsaXWYOhaivL4AAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 152,
    updatedAt: 2021-02-14T21:50:10.146Z,
    createdAt: 2021-02-14T21:50:10.146Z,
    name: null
  },
  _previousDataValues: {
    id: 152,
    name: null,
    createdAt: 2021-02-14T21:50:10.146Z,
    updatedAt: 2021-02-14T21:50:10.146Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 152
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [t9JKsaXWYOhaivL4AAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:50:10.134Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 152
}
Ligando o usuário [152] ao socket [163]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 152 AND (("Socket"."id" = 163)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (163)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 152;
Usuário [152] ligado ao socket [163], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [152]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 152 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 152 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/db/models/Room.js:150
        (await this.getPlayers()).forEach((player) => {
         ^^^^^

SyntaxError: missing ) after argument list
    at wrapSafe (node:internal/modules/cjs/loader:1024:16)
    at Module._compile (node:internal/modules/cjs/loader:1072:27)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1137:10)
    at Module.load (node:internal/modules/cjs/loader:973:32)
    at Function.Module._load (node:internal/modules/cjs/loader:813:14)
    at Module.require (node:internal/modules/cjs/loader:997:19)
    at require (node:internal/modules/cjs/helpers:92:18)
    at Object.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/lib/services/rooms.js:7:17)
    at Module._compile (node:internal/modules/cjs/loader:1108:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1137:10)
    at Module.load (node:internal/modules/cjs/loader:973:32)
    at Function.Module._load (node:internal/modules/cjs/loader:813:14)
    at Module.require (node:internal/modules/cjs/loader:997:19)
    at require (node:internal/modules/cjs/helpers:92:18)
    at Object.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:6:15)
    at Module._compile (node:internal/modules/cjs/loader:1108:14)
    at Object.Module._extensions..js (node:internal/modules/cjs/loader:1137:10)
    at Module.load (node:internal/modules/cjs/loader:973:32)
    at Function.Module._load (node:internal/modules/cjs/loader:813:14)
    at Function.executeUserEntryPoint [as runMain] (node:internal/modules/run_main:76:12)
    at node:internal/main/run_main_module:17:47
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [9vC7ztCdxXzfWiwqAAAA]
Conteúdo de handshake da socket [9vC7ztCdxXzfWiwqAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AkOFOIUdSzIPMLDc6D4vqd5GtqFk9kqUY.sjfop9yxf1vOEUpba6%2Frs7vAmEMrEeJcFwGh8adNz48; io=t9JKsaXWYOhaivL4AAAB"
  },
  "time": "Sun Feb 14 2021 18:51:14 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339474703,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYXhhr",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYXhhr"
  }
}
Conteúdo da sessão da socket [9vC7ztCdxXzfWiwqAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:51:14.699Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [9vC7ztCdxXzfWiwqAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 153,
    updatedAt: 2021-02-14T21:51:14.762Z,
    createdAt: 2021-02-14T21:51:14.762Z,
    name: null
  },
  _previousDataValues: {
    id: 153,
    name: null,
    createdAt: 2021-02-14T21:51:14.762Z,
    updatedAt: 2021-02-14T21:51:14.762Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 153
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [9vC7ztCdxXzfWiwqAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:51:14.699Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 153
}
Ligando o usuário [153] ao socket [164]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 153 AND (("Socket"."id" = 164)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (164)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 153;
Usuário [153] ligado ao socket [164], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [153]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 153 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 153 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [qP43lWc_id5XIvLWAAAB]
Conteúdo de handshake da socket [qP43lWc_id5XIvLWAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=NwtCWhSZ2faHE3UwAAAA; connect.sid=s%3AVRharmLR-cwOPa2UpMkvmSDyjmlOBGuu.vSFIbB3Jx%2BBP6YvLSQLEm5praC2uM%2FMTGt9EX1Be7xc"
  },
  "time": "Sun Feb 14 2021 18:51:16 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339476113,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYXi29",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYXi29"
  }
}
Conteúdo da sessão da socket [qP43lWc_id5XIvLWAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:51:16.112Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [qP43lWc_id5XIvLWAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 154,
    updatedAt: 2021-02-14T21:51:16.133Z,
    createdAt: 2021-02-14T21:51:16.133Z,
    name: null
  },
  _previousDataValues: {
    id: 154,
    name: null,
    createdAt: 2021-02-14T21:51:16.133Z,
    updatedAt: 2021-02-14T21:51:16.133Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 154
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [qP43lWc_id5XIvLWAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:51:16.112Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 154
}
Ligando o usuário [154] ao socket [165]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 154 AND (("Socket"."id" = 165)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (165)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 154;
Usuário [154] ligado ao socket [165], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [154]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 154 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 154 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [ngX4eMz22nUQ7IVaAAAA]
Conteúdo de handshake da socket [ngX4eMz22nUQ7IVaAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AvibgqnlHABrGw1n-s9NryPTZ6CdqwlUO.JmMT93Jpgvl21JNOkBhoSNtYiDR3Z5%2F%2FvA42J4cKuVs; io=9vC7ztCdxXzfWiwqAAAA"
  },
  "time": "Sun Feb 14 2021 18:52:35 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339555095,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYX_Jz",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYX_Jz"
  }
}
Conteúdo da sessão da socket [ngX4eMz22nUQ7IVaAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:52:35.092Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [ngX4eMz22nUQ7IVaAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 155,
    updatedAt: 2021-02-14T21:52:35.156Z,
    createdAt: 2021-02-14T21:52:35.156Z,
    name: null
  },
  _previousDataValues: {
    id: 155,
    name: null,
    createdAt: 2021-02-14T21:52:35.156Z,
    updatedAt: 2021-02-14T21:52:35.156Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 155
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [ngX4eMz22nUQ7IVaAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:52:35.092Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 155
}
Ligando o usuário [155] ao socket [166]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 155 AND (("Socket"."id" = 166)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (166)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 155;
Usuário [155] ligado ao socket [166], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [155]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 155 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 155 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [_k0DpiOltMC33FNLAAAB]
Conteúdo de handshake da socket [_k0DpiOltMC33FNLAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=qP43lWc_id5XIvLWAAAB; connect.sid=s%3ACG5Wkdjv0zLcLst6eozsX6uuL67eVQq3.8NZJmphhtVCwq5cKKHEW1iBNTXr38Uw6AI5ZCFcVHfY"
  },
  "time": "Sun Feb 14 2021 18:52:35 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339555350,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYX_OG",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYX_OG"
  }
}
Conteúdo da sessão da socket [_k0DpiOltMC33FNLAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:52:35.350Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [_k0DpiOltMC33FNLAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 156,
    updatedAt: 2021-02-14T21:52:35.365Z,
    createdAt: 2021-02-14T21:52:35.365Z,
    name: null
  },
  _previousDataValues: {
    id: 156,
    name: null,
    createdAt: 2021-02-14T21:52:35.365Z,
    updatedAt: 2021-02-14T21:52:35.365Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 156
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [_k0DpiOltMC33FNLAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:52:35.350Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 156
}
Ligando o usuário [156] ao socket [167]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 156 AND (("Socket"."id" = 167)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (167)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 156;
Usuário [156] ligado ao socket [167], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [156]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 156 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 156 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [-u4wUgbR2WCcqi4FAAAA]
Conteúdo de handshake da socket [-u4wUgbR2WCcqi4FAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AkNwUhL0v8DZyZQ41-fjsyJbvko27eNW-.Pulzzj4bB9UfyWWkIsc07O5Z5Cu6PAJWozJXmAR0xEE; io=ngX4eMz22nUQ7IVaAAAA"
  },
  "time": "Sun Feb 14 2021 18:53:54 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339634994,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYYIqL",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYYIqL"
  }
}
Conteúdo da sessão da socket [-u4wUgbR2WCcqi4FAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:53:54.988Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [-u4wUgbR2WCcqi4FAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
User {
  dataValues: {
    id: 157,
    updatedAt: 2021-02-14T21:53:55.054Z,
    createdAt: 2021-02-14T21:53:55.054Z,
    name: null
  },
  _previousDataValues: {
    id: 157,
    name: null,
    createdAt: 2021-02-14T21:53:55.054Z,
    updatedAt: 2021-02-14T21:53:55.054Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 157
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [-u4wUgbR2WCcqi4FAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:53:54.988Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 157
}
Ligando o usuário [157] ao socket [168]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 157 AND (("Socket"."id" = 168)));
[io.on('connect') - Nova socket conectada com id [2v9uedfuIowIZN6DAAAB]
Conteúdo de handshake da socket [2v9uedfuIowIZN6DAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=_k0DpiOltMC33FNLAAAB; connect.sid=s%3AnyQH3qCbujf14b4f4aGZLKKyG47Xzqf_.nsrfoTrjrAcLBDNoSWh7PtW3PJ8KUetHZBooL95NFnw"
  },
  "time": "Sun Feb 14 2021 18:53:55 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339635058,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYYIri",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYYIri"
  }
}
Conteúdo da sessão da socket [2v9uedfuIowIZN6DAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:53:55.058Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [2v9uedfuIowIZN6DAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (168)
User {
  dataValues: {
    id: 158,
    updatedAt: 2021-02-14T21:53:55.071Z,
    createdAt: 2021-02-14T21:53:55.071Z,
    name: null
  },
  _previousDataValues: {
    id: 158,
    name: null,
    createdAt: 2021-02-14T21:53:55.071Z,
    updatedAt: 2021-02-14T21:53:55.071Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 158
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [2v9uedfuIowIZN6DAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:53:55.058Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 158
}
Ligando o usuário [158] ao socket [169]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 158 AND (("Socket"."id" = 169)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (169)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 157;
Usuário [157] ligado ao socket [168], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [157]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 157 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 157 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 158;
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [158] ligado ao socket [169], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [158]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 158 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 158 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [Hc-7oy8lI63yRNC7AAAA]
Conteúdo de handshake da socket [Hc-7oy8lI63yRNC7AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=2v9uedfuIowIZN6DAAAB; connect.sid=s%3ApN2ix7CbVVnLQZqJnEzMsUMnsXyhLmWb.7w2ZY28%2BJKynlOKb8oHXeAHmofM275Q8AScXUBZJBAA"
  },
  "time": "Sun Feb 14 2021 18:54:40 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339680454,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYYTwl",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYYTwl"
  }
}
Conteúdo da sessão da socket [Hc-7oy8lI63yRNC7AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:54:40.450Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [Hc-7oy8lI63yRNC7AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
[io.on('connect') - Nova socket conectada com id [nYowWW4BTsU4ZOc7AAAB]
Conteúdo de handshake da socket [nYowWW4BTsU4ZOc7AAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3ApE81jG3QTIUxCr40qKbslgpsv9uaUI6b.9MeEuQ4WqF%2BhOLabzDQiYuLA09Ofk7XX0OYu8GQwvxU; io=-u4wUgbR2WCcqi4FAAAA"
  },
  "time": "Sun Feb 14 2021 18:54:40 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339680489,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYYTwz",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYYTwz"
  }
}
Conteúdo da sessão da socket [nYowWW4BTsU4ZOc7AAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:54:40.489Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [nYowWW4BTsU4ZOc7AAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 159,
    updatedAt: 2021-02-14T21:54:40.523Z,
    createdAt: 2021-02-14T21:54:40.523Z,
    name: null
  },
  _previousDataValues: {
    id: 159,
    name: null,
    createdAt: 2021-02-14T21:54:40.523Z,
    updatedAt: 2021-02-14T21:54:40.523Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 159
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [Hc-7oy8lI63yRNC7AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:54:40.450Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 159
}
Ligando o usuário [159] ao socket [170]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 159 AND (("Socket"."id" = 170)));
User {
  dataValues: {
    id: 160,
    updatedAt: 2021-02-14T21:54:40.526Z,
    createdAt: 2021-02-14T21:54:40.526Z,
    name: null
  },
  _previousDataValues: {
    id: 160,
    name: null,
    createdAt: 2021-02-14T21:54:40.526Z,
    updatedAt: 2021-02-14T21:54:40.526Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 160
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [nYowWW4BTsU4ZOc7AAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:54:40.489Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 160
}
Ligando o usuário [160] ao socket [171]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 160 AND (("Socket"."id" = 171)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (170)
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (171)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 159;
Usuário [159] ligado ao socket [170], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [159]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 160;
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 159 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 159 ) ON "Room"."id" = "players"."roomId";
Usuário [160] ligado ao socket [171], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [160]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 160 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 160 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [2zlE1Pgnk75qE9AfAAAA]
Conteúdo de handshake da socket [2zlE1Pgnk75qE9AfAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AFC5EXQo953WXMQkQR6JAGvZvfOu8n2a7.nvtiEuXejr%2Bp%2F3mE%2BwTpN82gDS%2FsYc5pUB0j5W3ga6M; io=nYowWW4BTsU4ZOc7AAAB"
  },
  "time": "Sun Feb 14 2021 18:55:10 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339710468,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYYbFf",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYYbFf"
  }
}
Conteúdo da sessão da socket [2zlE1Pgnk75qE9AfAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:55:10.464Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [2zlE1Pgnk75qE9AfAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 161,
    updatedAt: 2021-02-14T21:55:10.525Z,
    createdAt: 2021-02-14T21:55:10.525Z,
    name: null
  },
  _previousDataValues: {
    id: 161,
    name: null,
    createdAt: 2021-02-14T21:55:10.525Z,
    updatedAt: 2021-02-14T21:55:10.525Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 161
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [2zlE1Pgnk75qE9AfAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:55:10.464Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 161
}
Ligando o usuário [161] ao socket [172]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 161 AND (("Socket"."id" = 172)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (172)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 161;
Usuário [161] ligado ao socket [172], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [161]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 161 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 161 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [m_ctcp9uNHz4tYMsAAAB]
Conteúdo de handshake da socket [m_ctcp9uNHz4tYMsAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=Hc-7oy8lI63yRNC7AAAA; connect.sid=s%3AgyRe8nVlg6KIR7RFTDra8yTbi8vlaLs-.hcVxaiFIu7B%2FpjF15etyxZ3JPwlQf%2BKH95mdQvgx%2FvQ"
  },
  "time": "Sun Feb 14 2021 18:55:10 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339710656,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYYbIt",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYYbIt"
  }
}
Conteúdo da sessão da socket [m_ctcp9uNHz4tYMsAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:55:10.655Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [m_ctcp9uNHz4tYMsAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 162,
    updatedAt: 2021-02-14T21:55:10.676Z,
    createdAt: 2021-02-14T21:55:10.676Z,
    name: null
  },
  _previousDataValues: {
    id: 162,
    name: null,
    createdAt: 2021-02-14T21:55:10.676Z,
    updatedAt: 2021-02-14T21:55:10.676Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 162
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [m_ctcp9uNHz4tYMsAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:55:10.655Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 162
}
Ligando o usuário [162] ao socket [173]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 162 AND (("Socket"."id" = 173)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (173)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 162;
Usuário [162] ligado ao socket [173], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [162]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 162 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 162 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [cvu-8ttptNJne0WAAAAA]
Conteúdo de handshake da socket [cvu-8ttptNJne0WAAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=sa",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3A98K0O3aMz5AyaTkYKr7KTQS-kfSNa8et.qSOnkWiPm%2BLW%2BYnJMSGIGucQfzrnYgeRfuh40fZDWDI; io=2zlE1Pgnk75qE9AfAAAA"
  },
  "time": "Sun Feb 14 2021 18:56:36 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339796179,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYYwAl",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYYwAl"
  }
}
Conteúdo da sessão da socket [cvu-8ttptNJne0WAAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:56:36.175Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [cvu-8ttptNJne0WAAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 163,
    updatedAt: 2021-02-14T21:56:36.252Z,
    createdAt: 2021-02-14T21:56:36.252Z,
    name: null
  },
  _previousDataValues: {
    id: 163,
    name: null,
    createdAt: 2021-02-14T21:56:36.252Z,
    updatedAt: 2021-02-14T21:56:36.252Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 163
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [cvu-8ttptNJne0WAAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:56:36.175Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 163
}
Ligando o usuário [163] ao socket [174]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 163 AND (("Socket"."id" = 174)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (174)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 163;
Usuário [163] ligado ao socket [174], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [163]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 163 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 163 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [mh_a3OpYVizLWL50AAAB]
Conteúdo de handshake da socket [mh_a3OpYVizLWL50AAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=m_ctcp9uNHz4tYMsAAAB; connect.sid=s%3Ao_je75UvZinDgRGMgtK4w86T_4iU9Hvb.HCagdUz9vUIr4wSQnZRDo2pzpDKRB2nIef3fsltlDaA"
  },
  "time": "Sun Feb 14 2021 18:56:36 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339796349,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYYwDw",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYYwDw"
  }
}
Conteúdo da sessão da socket [mh_a3OpYVizLWL50AAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:56:36.348Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [mh_a3OpYVizLWL50AAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 164,
    updatedAt: 2021-02-14T21:56:36.358Z,
    createdAt: 2021-02-14T21:56:36.358Z,
    name: null
  },
  _previousDataValues: {
    id: 164,
    name: null,
    createdAt: 2021-02-14T21:56:36.358Z,
    updatedAt: 2021-02-14T21:56:36.358Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 164
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [mh_a3OpYVizLWL50AAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:56:36.348Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 164
}
Ligando o usuário [164] ao socket [175]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 164 AND (("Socket"."id" = 175)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (175)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 164;
Usuário [164] ligado ao socket [175], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [164]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 164 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 164 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [163] tentando entrar com nome [1] na sala com nome [sas]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 163 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 163 ) ON "Room"."id" = "players"."roomId";
Usuário [163] trocou o nome de [null] para [1]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [sas]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'sas' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
null
A sala que o usuário tentou entrar [sas] não existe ainda, vamos criar uma para ele
Criando uma sala com nome [sas] para o hostPlayer [1]
Buscando uma sala com nome [sas]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'sas' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Procurando uma sala existente [Sala disponível]
Executing (default): INSERT INTO "rooms" ("id","state","name","turn","currentPlayerIndex","prompt","selectedCardCount","victory","votingCardsTurn","winner","minimumPlayersToStart","minimumCardsToStart","selectedDecksIds","deck","morto","results","createdAt","updatedAt","hostId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18) RETURNING *;
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
[]
Sala criada com nome [sas] e host player [1]
Buscando uma sala com nome [sas]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'sas' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Sala [sas] criada para o usuário [163]
Sala atual é: sas
Adicionando usuário [163] para a sala [sas] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 13;
Enviando mensagem do sistema [1 tá na área!] para a sala [sas]
Emitindo roomData para os sockets conectados na sala [sas]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 13;
emitindo RoomData para todos os sockets do usuário [163]
emitindo roomData para o socket [cvu-8ttptNJne0WAAAAA] do usuário [163]
Pegando player do usuário [163] na sala [13]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 13 AND "RoomPlayer"."userId" = 163);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [7tjxcKFi23IH2AXBAAAC]
Conteúdo de handshake da socket [7tjxcKFi23IH2AXBAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=mh_a3OpYVizLWL50AAAB; connect.sid=s%3AvyCm4POMfe7G6zx_YmpS1hejriRcIdF9.04%2BIHH%2Bm3qpSQx4tVn7h8saCv8JLpcJu9hEn2kTXRE8"
  },
  "time": "Sun Feb 14 2021 18:56:48 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339808048,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYYz4j",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYYz4j"
  }
}
Conteúdo da sessão da socket [7tjxcKFi23IH2AXBAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:56:48.047Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [7tjxcKFi23IH2AXBAAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 165,
    updatedAt: 2021-02-14T21:56:48.075Z,
    createdAt: 2021-02-14T21:56:48.075Z,
    name: null
  },
  _previousDataValues: {
    id: 165,
    name: null,
    createdAt: 2021-02-14T21:56:48.075Z,
    updatedAt: 2021-02-14T21:56:48.075Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 165
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [7tjxcKFi23IH2AXBAAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:56:48.047Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 165
}
Ligando o usuário [165] ao socket [176]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 165 AND (("Socket"."id" = 176)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (176)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 165;
Usuário [165] ligado ao socket [176], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [165]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 165 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 165 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [165] tentando entrar com nome [2] na sala com nome [sas]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 165 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 165 ) ON "Room"."id" = "players"."roomId";
Usuário [165] trocou o nome de [null] para [2]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [sas]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'sas' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 13,
    state: 'WAITING_FOR_PLAYERS',
    name: 'sas',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:56:43.455Z,
    updatedAt: 2021-02-14T21:56:43.455Z,
    hostId: 163,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 13,
    state: 'WAITING_FOR_PLAYERS',
    name: 'sas',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:56:43.455Z,
    updatedAt: 2021-02-14T21:56:43.455Z,
    hostId: 163,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'sas' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 163,
      name: '1',
      createdAt: 2021-02-14T21:56:36.252Z,
      updatedAt: 2021-02-14T21:56:43.435Z
    },
    _previousDataValues: {
      id: 163,
      name: '1',
      createdAt: 2021-02-14T21:56:36.252Z,
      updatedAt: 2021-02-14T21:56:43.435Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [sas] que o usuário [165] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 13 AND "RoomPlayer"."userId" = 165);
Tentando adicionar usuário [2] na sala [sas]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = '2' WHERE "RoomPlayer"."roomId" = 13;
Adicionando usuário [165] à sala [sas]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: sas
Adicionando usuário [165] para a sala [sas] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 13;
Enviando mensagem do sistema [2 tá na área!] para a sala [sas]
Emitindo roomData para os sockets conectados na sala [sas]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 13;
emitindo RoomData para todos os sockets do usuário [163]
emitindo roomData para o socket [cvu-8ttptNJne0WAAAAA] do usuário [163]
emitindo RoomData para todos os sockets do usuário [165]
emitindo roomData para o socket [7tjxcKFi23IH2AXBAAAC] do usuário [165]
Pegando player do usuário [165] na sala [13]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 13 AND "RoomPlayer"."userId" = 165);
Usuário [163] com socket [cvu-8ttptNJne0WAAAAA] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 174
retornando a sala do jogador [1] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 163 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 163 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 163;
Enviando mensagem do sistema [1 meteu o pé.] para a sala [sas]
Emitindo roomData para os sockets conectados na sala [sas]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 13 AND "RoomPlayer"."userId" = 163);
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 13;
checando se o jogador atual está na última posição da fila.
jogador atual na última posição. Alterando o currentPlayerIndex para 0.
removendo roomPlayer de id [53] da sala [sas]
Executing (default): UPDATE "roomPlayers" SET "roomId"=$1,"updatedAt"=$2 WHERE "roomId" = $3 AND "id" IN (53)
emitindo RoomData para todos os sockets do usuário [165]
emitindo roomData para o socket [7tjxcKFi23IH2AXBAAAC] do usuário [165]
emitindo RoomData para todos os sockets do usuário [163]
Agora temos [1] usuários na sala
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [ScJv7Q7NDbk91Ne8AAAD]
Conteúdo de handshake da socket [ScJv7Q7NDbk91Ne8AAAD]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/sas",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AVLUDji4bTFJRB9UHHs1crUbCyMon97DJ.Cl4VCprDTnq%2BFhCfowNltwD5fajDlDwfL9AaokazIe4; io=cvu-8ttptNJne0WAAAAA"
  },
  "time": "Sun Feb 14 2021 18:56:59 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339819127,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYY_nr",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYY_nr"
  }
}
Conteúdo da sessão da socket [ScJv7Q7NDbk91Ne8AAAD]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:56:59.126Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [ScJv7Q7NDbk91Ne8AAAD] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 166,
    updatedAt: 2021-02-14T21:56:59.131Z,
    createdAt: 2021-02-14T21:56:59.131Z,
    name: null
  },
  _previousDataValues: {
    id: 166,
    name: null,
    createdAt: 2021-02-14T21:56:59.131Z,
    updatedAt: 2021-02-14T21:56:59.131Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 166
Usuário adicionado, agora temos [4] usuário(s)
Salvando sessao da socket [ScJv7Q7NDbk91Ne8AAAD]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:56:59.126Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 166
}
Ligando o usuário [166] ao socket [177]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 166 AND (("Socket"."id" = 177)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (177)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 166;
Usuário [166] ligado ao socket [177], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [166]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 166 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 166 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [166] tentando entrar com nome [1] na sala com nome [sas]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 166 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 166 ) ON "Room"."id" = "players"."roomId";
Usuário [166] trocou o nome de [null] para [1]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [sas]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = 'sas' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 13,
    state: 'WAITING_FOR_PLAYERS',
    name: 'sas',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:56:43.455Z,
    updatedAt: 2021-02-14T21:56:43.455Z,
    hostId: 163,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 13,
    state: 'WAITING_FOR_PLAYERS',
    name: 'sas',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:56:43.455Z,
    updatedAt: 2021-02-14T21:56:43.455Z,
    hostId: 163,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: 'sas' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 163,
      name: '1',
      createdAt: 2021-02-14T21:56:36.252Z,
      updatedAt: 2021-02-14T21:56:43.435Z
    },
    _previousDataValues: {
      id: 163,
      name: '1',
      createdAt: 2021-02-14T21:56:36.252Z,
      updatedAt: 2021-02-14T21:56:43.435Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [sas] que o usuário [166] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 13 AND "RoomPlayer"."userId" = 166);
Tentando adicionar usuário [1] na sala [sas]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = '1' WHERE "RoomPlayer"."roomId" = 13;
Adicionando usuário [166] à sala [sas]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: sas
Adicionando usuário [166] para a sala [sas] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 13;
Enviando mensagem do sistema [1 tá na área!] para a sala [sas]
Emitindo roomData para os sockets conectados na sala [sas]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 13;
emitindo RoomData para todos os sockets do usuário [165]
emitindo roomData para o socket [7tjxcKFi23IH2AXBAAAC] do usuário [165]
emitindo RoomData para todos os sockets do usuário [166]
emitindo roomData para o socket [ScJv7Q7NDbk91Ne8AAAD] do usuário [166]
Pegando player do usuário [166] na sala [13]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 13 AND "RoomPlayer"."userId" = 166);
Usuário [165] com socket [7tjxcKFi23IH2AXBAAAC] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 176
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 165 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 165 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 165;
Enviando mensagem do sistema [2 meteu o pé.] para a sala [sas]
Emitindo roomData para os sockets conectados na sala [sas]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 13 AND "RoomPlayer"."userId" = 165);
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 13;
checando se o jogador atual está na última posição da fila.
jogador atual na última posição. Alterando o currentPlayerIndex para 0.
removendo roomPlayer de id [54] da sala [sas]
Executing (default): UPDATE "roomPlayers" SET "roomId"=$1,"updatedAt"=$2 WHERE "roomId" = $3 AND "id" IN (54)
emitindo RoomData para todos os sockets do usuário [166]
emitindo roomData para o socket [ScJv7Q7NDbk91Ne8AAAD] do usuário [166]
emitindo RoomData para todos os sockets do usuário [165]
Agora temos [1] usuários na sala
Usuário [166] com socket [ScJv7Q7NDbk91Ne8AAAD] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 177
retornando a sala do jogador [1] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 166 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 166 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 166;
Enviando mensagem do sistema [1 meteu o pé.] para a sala [sas]
Emitindo roomData para os sockets conectados na sala [sas]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 13 AND "RoomPlayer"."userId" = 166);
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 13;
checando se o jogador atual está na última posição da fila.
jogador atual na última posição. Alterando o currentPlayerIndex para 0.
removendo roomPlayer de id [55] da sala [sas]
emitindo RoomData para todos os sockets do usuário [166]
Executing (default): UPDATE "roomPlayers" SET "roomId"=$1,"updatedAt"=$2 WHERE "roomId" = $3 AND "id" IN (55)
Agora temos [1] usuários na sala
Usuário [164] com socket [mh_a3OpYVizLWL50AAAB] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 175
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 164 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 164 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 164;
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [fzpat9biBa6aeQoiAAAE]
Conteúdo de handshake da socket [fzpat9biBa6aeQoiAAAE]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AVLUDji4bTFJRB9UHHs1crUbCyMon97DJ.Cl4VCprDTnq%2BFhCfowNltwD5fajDlDwfL9AaokazIe4; io=ScJv7Q7NDbk91Ne8AAAD"
  },
  "time": "Sun Feb 14 2021 18:57:38 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339858178,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYZ9J_",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYZ9J_"
  }
}
Conteúdo da sessão da socket [fzpat9biBa6aeQoiAAAE]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:57:38.178Z",
    "httpOnly": true,
    "path": "/"
  },
  "userId": 166
}
Executing (default): SELECT "User"."id", "User"."name", "User"."createdAt", "User"."updatedAt", "sockets"."id" AS "sockets.id", "sockets"."socketId" AS "sockets.socketId", "sockets"."createdAt" AS "sockets.createdAt", "sockets"."updatedAt" AS "sockets.updatedAt", "sockets"."userId" AS "sockets.userId", "sockets"."roomId" AS "sockets.roomId" FROM "users" AS "User" LEFT OUTER JOIN "sockets" AS "sockets" ON "User"."id" = "sockets"."userId" WHERE "User"."id" = 166;
Detectei o usuário com id [166] para a socket com id [fzpat9biBa6aeQoiAAAE]
retornando a sala do jogador [1] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 166 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 166 ) ON "Room"."id" = "players"."roomId";
Ligando o usuário [166] ao socket [178]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 166 AND (("Socket"."id" = 178)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (178)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 166;
Usuário [166] ligado ao socket [178], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [166]
retornando a sala do jogador [1] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 166 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 166 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [166] tentando entrar com nome [pi] na sala com nome [123]
retornando a sala do jogador [1] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 166 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 166 ) ON "Room"."id" = "players"."roomId";
Usuário [166] trocou o nome de [1] para [pi]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [123]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '123' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
null
A sala que o usuário tentou entrar [123] não existe ainda, vamos criar uma para ele
Criando uma sala com nome [123] para o hostPlayer [pi]
Buscando uma sala com nome [123]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '123' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Procurando uma sala existente [Sala disponível]
Executing (default): INSERT INTO "rooms" ("id","state","name","turn","currentPlayerIndex","prompt","selectedCardCount","victory","votingCardsTurn","winner","minimumPlayersToStart","minimumCardsToStart","selectedDecksIds","deck","morto","results","createdAt","updatedAt","hostId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18) RETURNING *;
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
[]
Sala criada com nome [123] e host player [pi]
Buscando uma sala com nome [123]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '123' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Sala [123] criada para o usuário [166]
Sala atual é: 123
Adicionando usuário [166] para a sala [123] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 14;
Enviando mensagem do sistema [pi tá na área!] para a sala [123]
Emitindo roomData para os sockets conectados na sala [123]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 14;
emitindo RoomData para todos os sockets do usuário [166]
emitindo roomData para o socket [fzpat9biBa6aeQoiAAAE] do usuário [166]
Pegando player do usuário [166] na sala [14]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 14 AND "RoomPlayer"."userId" = 166);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [WVnbLdXI_ZeOPpUpAAAF]
Conteúdo de handshake da socket [WVnbLdXI_ZeOPpUpAAAF]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/"
  },
  "time": "Sun Feb 14 2021 18:57:53 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339873509,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYZD3a",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYZD3a"
  }
}
Conteúdo da sessão da socket [WVnbLdXI_ZeOPpUpAAAF]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:57:53.509Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [WVnbLdXI_ZeOPpUpAAAF] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 167,
    updatedAt: 2021-02-14T21:57:53.541Z,
    createdAt: 2021-02-14T21:57:53.541Z,
    name: null
  },
  _previousDataValues: {
    id: 167,
    name: null,
    createdAt: 2021-02-14T21:57:53.541Z,
    updatedAt: 2021-02-14T21:57:53.541Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { id: 166 },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 167
Usuário adicionado, agora temos [5] usuário(s)
Salvando sessao da socket [WVnbLdXI_ZeOPpUpAAAF]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:57:53.509Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 167
}
Ligando o usuário [167] ao socket [179]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 167 AND (("Socket"."id" = 179)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (179)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 167;
Usuário [167] ligado ao socket [179], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [167]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 167 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 167 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [167] tentando entrar com nome [pi2] na sala com nome [123]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 167 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 167 ) ON "Room"."id" = "players"."roomId";
Usuário [167] trocou o nome de [null] para [pi2]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [123]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '123' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 14,
    state: 'WAITING_FOR_PLAYERS',
    name: '123',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:57:48.496Z,
    updatedAt: 2021-02-14T21:57:48.496Z,
    hostId: 166,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 14,
    state: 'WAITING_FOR_PLAYERS',
    name: '123',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T21:57:48.496Z,
    updatedAt: 2021-02-14T21:57:48.496Z,
    hostId: 166,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: '123' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 166,
      name: 'pi',
      createdAt: 2021-02-14T21:56:59.131Z,
      updatedAt: 2021-02-14T21:57:48.469Z
    },
    _previousDataValues: {
      id: 166,
      name: 'pi',
      createdAt: 2021-02-14T21:56:59.131Z,
      updatedAt: 2021-02-14T21:57:48.469Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: [Object],
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [123] que o usuário [167] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 14 AND "RoomPlayer"."userId" = 167);
Tentando adicionar usuário [pi2] na sala [123]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = 'pi2' WHERE "RoomPlayer"."roomId" = 14;
Adicionando usuário [167] à sala [123]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: 123
Adicionando usuário [167] para a sala [123] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 14;
Enviando mensagem do sistema [pi2 tá na área!] para a sala [123]
Emitindo roomData para os sockets conectados na sala [123]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 14;
emitindo RoomData para todos os sockets do usuário [166]
emitindo roomData para o socket [fzpat9biBa6aeQoiAAAE] do usuário [166]
emitindo RoomData para todos os sockets do usuário [167]
emitindo roomData para o socket [WVnbLdXI_ZeOPpUpAAAF] do usuário [167]
Pegando player do usuário [167] na sala [14]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 14 AND "RoomPlayer"."userId" = 167);
retornando a sala do jogador [pi] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 166 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 166 ) ON "Room"."id" = "players"."roomId";
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:170
    if (userRoom.host.id != user.id) {
                      ^

TypeError: Cannot read property 'id' of undefined
    at Socket.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:170:23)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [lu0ayAbZG-OuRXR9AAAA]
Conteúdo de handshake da socket [lu0ayAbZG-OuRXR9AAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=WVnbLdXI_ZeOPpUpAAAF; connect.sid=s%3AZKWXYwY6fQEtn8tmzgsWFsHlPOqCOTlE.tA%2BOBxvDJJu9Phxgh3d9LyiDmX31sZFZy2HJPsVXrUo"
  },
  "time": "Sun Feb 14 2021 18:58:59 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339939901,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYZTGV",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYZTGV"
  }
}
Conteúdo da sessão da socket [lu0ayAbZG-OuRXR9AAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:58:59.896Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [lu0ayAbZG-OuRXR9AAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 168,
    updatedAt: 2021-02-14T21:58:59.961Z,
    createdAt: 2021-02-14T21:58:59.961Z,
    name: null
  },
  _previousDataValues: {
    id: 168,
    name: null,
    createdAt: 2021-02-14T21:58:59.961Z,
    updatedAt: 2021-02-14T21:58:59.961Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 168
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [lu0ayAbZG-OuRXR9AAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:58:59.896Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 168
}
Ligando o usuário [168] ao socket [180]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 168 AND (("Socket"."id" = 180)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (180)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 168;
Usuário [168] ligado ao socket [180], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [168]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 168 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 168 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [1y8qANsDFuTIpsaAAAAB]
Conteúdo de handshake da socket [1y8qANsDFuTIpsaAAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/123",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AVLUDji4bTFJRB9UHHs1crUbCyMon97DJ.Cl4VCprDTnq%2BFhCfowNltwD5fajDlDwfL9AaokazIe4; io=fzpat9biBa6aeQoiAAAE"
  },
  "time": "Sun Feb 14 2021 18:59:02 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613339942289,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYZTsC",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYZTsC"
  }
}
Conteúdo da sessão da socket [1y8qANsDFuTIpsaAAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T21:59:02.289Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [1y8qANsDFuTIpsaAAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 169,
    updatedAt: 2021-02-14T21:59:02.300Z,
    createdAt: 2021-02-14T21:59:02.300Z,
    name: null
  },
  _previousDataValues: {
    id: 169,
    name: null,
    createdAt: 2021-02-14T21:59:02.300Z,
    updatedAt: 2021-02-14T21:59:02.300Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 169
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [1y8qANsDFuTIpsaAAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T21:59:02.289Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 169
}
Ligando o usuário [169] ao socket [181]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 169 AND (("Socket"."id" = 181)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (181)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 169;
Usuário [169] ligado ao socket [181], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [169]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 169 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 169 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [169] tentando entrar com nome [o] na sala com nome [2]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 169 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 169 ) ON "Room"."id" = "players"."roomId";
Usuário [169] trocou o nome de [null] para [o]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
null
A sala que o usuário tentou entrar [2] não existe ainda, vamos criar uma para ele
Criando uma sala com nome [2] para o hostPlayer [o]
Buscando uma sala com nome [2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Procurando uma sala existente [Sala disponível]
Executing (default): INSERT INTO "rooms" ("id","state","name","turn","currentPlayerIndex","prompt","selectedCardCount","victory","votingCardsTurn","winner","minimumPlayersToStart","minimumCardsToStart","selectedDecksIds","deck","morto","results","createdAt","updatedAt","hostId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18) RETURNING *;
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
[]
Sala criada com nome [2] e host player [o]
Buscando uma sala com nome [2]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '2' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Sala [2] criada para o usuário [169]
Sala atual é: 2
Adicionando usuário [169] para a sala [2] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 15;
Enviando mensagem do sistema [o tá na área!] para a sala [2]
Emitindo roomData para os sockets conectados na sala [2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 15;
emitindo RoomData para todos os sockets do usuário [169]
emitindo roomData para o socket [1y8qANsDFuTIpsaAAAAB] do usuário [169]
Pegando player do usuário [169] na sala [15]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 15 AND "RoomPlayer"."userId" = 169);
retornando a sala do jogador [o] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 169 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 169 ) ON "Room"."id" = "players"."roomId";
Selecionando estado do deck [nudes] para a sala [15]
Adicionando o deck [nudes] da sala [15]
Emitindo roomData para os sockets conectados na sala [2]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 15;
emitindo RoomData para todos os sockets do usuário [169]
emitindo roomData para o socket [1y8qANsDFuTIpsaAAAAB] do usuário [169]
retornando a sala do jogador [o] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 169 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 169 ) ON "Room"."id" = "players"."roomId";
/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:187
    if (userRoom.host.id != user.id) {
                      ^

TypeError: Cannot read property 'id' of undefined
    at Socket.<anonymous> (/home/sandesvitor/Projeckts/Kah-Dix-v2/server/src/index.js:187:23)
[31m[nodemon] app crashed - waiting for file changes before starting...[39m
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [KuVH6y1rVZO8I83kAAAA]
Conteúdo de handshake da socket [KuVH6y1rVZO8I83kAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/2",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AHXUgyCVfunVmDWgBwq2dw9s9LNrCCl6S.B%2FH78n5BCxwgNCFovOWIpsUfRIZfQN16T1PJI0u1diA; io=1y8qANsDFuTIpsaAAAAB"
  },
  "time": "Sun Feb 14 2021 19:00:55 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613340055281,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYZvRX",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYZvRX"
  }
}
Conteúdo da sessão da socket [KuVH6y1rVZO8I83kAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T22:00:55.279Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [KuVH6y1rVZO8I83kAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 170,
    updatedAt: 2021-02-14T22:00:55.339Z,
    createdAt: 2021-02-14T22:00:55.339Z,
    name: null
  },
  _previousDataValues: {
    id: 170,
    name: null,
    createdAt: 2021-02-14T22:00:55.339Z,
    updatedAt: 2021-02-14T22:00:55.339Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 170
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [KuVH6y1rVZO8I83kAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T22:00:55.279Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 170
}
Ligando o usuário [170] ao socket [182]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 170 AND (("Socket"."id" = 182)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (182)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 170;
Usuário [170] ligado ao socket [182], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [170]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 170 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 170 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [K2TLWaugpdUbVZbyAAAB]
Conteúdo de handshake da socket [K2TLWaugpdUbVZbyAAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=lu0ayAbZG-OuRXR9AAAA; connect.sid=s%3ABvJqr-W0yTNMXXDcFuJdW8-a8mge3m4y.e63ddFK7Q8GAzMamGe%2BTVLPybGTXRZCtUTf9ddZElVk"
  },
  "time": "Sun Feb 14 2021 19:00:55 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613340055550,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYZvVt",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYZvVt"
  }
}
Conteúdo da sessão da socket [K2TLWaugpdUbVZbyAAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T22:00:55.549Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [K2TLWaugpdUbVZbyAAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 171,
    updatedAt: 2021-02-14T22:00:55.569Z,
    createdAt: 2021-02-14T22:00:55.569Z,
    name: null
  },
  _previousDataValues: {
    id: 171,
    name: null,
    createdAt: 2021-02-14T22:00:55.569Z,
    updatedAt: 2021-02-14T22:00:55.569Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 171
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [K2TLWaugpdUbVZbyAAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T22:00:55.549Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 171
}
Ligando o usuário [171] ao socket [183]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 171 AND (("Socket"."id" = 183)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (183)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 171;
Usuário [171] ligado ao socket [183], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [171]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 171 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 171 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
[32m[nodemon] restarting due to changes...[39m
[32m[nodemon] starting `node src/index.js`[39m

██╗  ██╗█████╗██╗  ██╗    ██████╗████╗  ████████████╗
██║ ██╔██╔══████║  ██║    ██╔══████╚██╗██╔██╚══██╔══╝
█████╔╝██████████████║    ██║  ████║╚███╔╝██║  ██║   
██╔═██╗██╔══████╔══██║    ██║  ████║██╔██╗██║  ██║   
██║  ████║  ████║  ██║    ██████╔████╔╝ ████║  ██║   
████████████████████╗██╗  ╚███████████████╗═╝  ╚═╝   
██╔════██╔════██╔══████║   ████╔════██╔══██╗         
████████████╗ ██████╔██║   ███████╗ ██████╔╝         
╚════████╔══╝ ██╔══██╚██╗ ██╔██╔══╝ ██╔══██╗         
████████████████║  ██║╚████╔╝█████████║  ██║         
╚══════╚══════╚═╝  ╚═╝ ╚═══╝ ╚══════╚═╝  ╚═╝ 

      ######### Server running on port: [5000] #########

Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [f9VHYsspFrGd29XzAAAA]
Conteúdo de handshake da socket [f9VHYsspFrGd29XzAAAA]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/",
    "cookie": "io=K2TLWaugpdUbVZbyAAAB; connect.sid=s%3Asbfef9HQVvaKMdNpG4TZtzoZm3ts7RA3.am8jYKQHjVHiJ9ls7ToikvnwWPvEZlW42C8Xs4gcL9A"
  },
  "time": "Sun Feb 14 2021 19:01:12 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613340072536,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYZzfB",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYZzfB"
  }
}
Conteúdo da sessão da socket [f9VHYsspFrGd29XzAAAA]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T22:01:12.534Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [f9VHYsspFrGd29XzAAAA] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 172,
    updatedAt: 2021-02-14T22:01:12.590Z,
    createdAt: 2021-02-14T22:01:12.590Z,
    name: null
  },
  _previousDataValues: {
    id: 172,
    name: null,
    createdAt: 2021-02-14T22:01:12.590Z,
    updatedAt: 2021-02-14T22:01:12.590Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 172
Usuário adicionado, agora temos [1] usuário(s)
Salvando sessao da socket [f9VHYsspFrGd29XzAAAA]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T22:01:12.534Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 172
}
Ligando o usuário [172] ao socket [184]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 172 AND (("Socket"."id" = 184)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (184)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 172;
Usuário [172] ligado ao socket [184], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [172]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 172 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 172 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [sP6FuitFpUaFf2-9AAAB]
Conteúdo de handshake da socket [sP6FuitFpUaFf2-9AAAB]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/?roomName=2",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AWaBqZ-98wKOWmZAJoEjEOExQzpN9J_kJ.zVZ6P5TqjdICbGsrTbMIYAosIkiBQtL%2BR0H3%2BkbqLcE; io=KuVH6y1rVZO8I83kAAAA"
  },
  "time": "Sun Feb 14 2021 19:01:13 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613340073234,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYZzqC",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYZzqC"
  }
}
Conteúdo da sessão da socket [sP6FuitFpUaFf2-9AAAB]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T22:01:13.233Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [sP6FuitFpUaFf2-9AAAB] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 173,
    updatedAt: 2021-02-14T22:01:13.245Z,
    createdAt: 2021-02-14T22:01:13.245Z,
    name: null
  },
  _previousDataValues: {
    id: 173,
    name: null,
    createdAt: 2021-02-14T22:01:13.245Z,
    updatedAt: 2021-02-14T22:01:13.245Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 173
Usuário adicionado, agora temos [2] usuário(s)
Salvando sessao da socket [sP6FuitFpUaFf2-9AAAB]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T22:01:13.233Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 173
}
Ligando o usuário [173] ao socket [185]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 173 AND (("Socket"."id" = 185)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (185)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 173;
Usuário [173] ligado ao socket [185], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [173]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [172] com socket [f9VHYsspFrGd29XzAAAA] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 184
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 172 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 172 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 172;
Usuário [173] tentando entrar com nome [2] na sala com nome [3]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Usuário [173] trocou o nome de [null] para [2]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [3]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '3' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
null
A sala que o usuário tentou entrar [3] não existe ainda, vamos criar uma para ele
Criando uma sala com nome [3] para o hostPlayer [2]
Buscando uma sala com nome [3]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '3' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Procurando uma sala existente [Sala disponível]
Executing (default): INSERT INTO "rooms" ("id","state","name","turn","currentPlayerIndex","prompt","selectedCardCount","victory","votingCardsTurn","winner","minimumPlayersToStart","minimumCardsToStart","selectedDecksIds","deck","morto","results","createdAt","updatedAt","hostId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18) RETURNING *;
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
[]
Sala criada com nome [3] e host player [2]
Buscando uma sala com nome [3]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '3' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Sala [3] criada para o usuário [173]
Sala atual é: 3
Adicionando usuário [173] para a sala [3] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 16;
Enviando mensagem do sistema [2 tá na área!] para a sala [3]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
Pegando player do usuário [173] na sala [16]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 16 AND "RoomPlayer"."userId" = 173);
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [Fce5mfVQkpLWCYrwAAAC]
Conteúdo de handshake da socket [Fce5mfVQkpLWCYrwAAAC]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "dnt": "1",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/"
  },
  "time": "Sun Feb 14 2021 19:01:27 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613340087425,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYa1H_",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYa1H_"
  }
}
Conteúdo da sessão da socket [Fce5mfVQkpLWCYrwAAAC]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T22:01:27.425Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [Fce5mfVQkpLWCYrwAAAC] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 174,
    updatedAt: 2021-02-14T22:01:27.432Z,
    createdAt: 2021-02-14T22:01:27.432Z,
    name: null
  },
  _previousDataValues: {
    id: 174,
    name: null,
    createdAt: 2021-02-14T22:01:27.432Z,
    updatedAt: 2021-02-14T22:01:27.432Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 174
Usuário adicionado, agora temos [3] usuário(s)
Salvando sessao da socket [Fce5mfVQkpLWCYrwAAAC]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T22:01:27.425Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 174
}
Ligando o usuário [174] ao socket [186]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 174 AND (("Socket"."id" = 186)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (186)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 174;
Usuário [174] ligado ao socket [186], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [174]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 174 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 174 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [174] tentando entrar com nome [1] na sala com nome [3]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 174 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 174 ) ON "Room"."id" = "players"."roomId";
Usuário [174] trocou o nome de [null] para [1]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [3]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '3' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 16,
    state: 'WAITING_FOR_PLAYERS',
    name: '3',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T22:01:22.102Z,
    updatedAt: 2021-02-14T22:01:22.102Z,
    hostId: 173,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 16,
    state: 'WAITING_FOR_PLAYERS',
    name: '3',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'points-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T22:01:22.102Z,
    updatedAt: 2021-02-14T22:01:22.102Z,
    hostId: 173,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: '3' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 173,
      name: '2',
      createdAt: 2021-02-14T22:01:13.245Z,
      updatedAt: 2021-02-14T22:01:22.081Z
    },
    _previousDataValues: {
      id: 173,
      name: '2',
      createdAt: 2021-02-14T22:01:13.245Z,
      updatedAt: 2021-02-14T22:01:22.081Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [3] que o usuário [174] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 16 AND "RoomPlayer"."userId" = 174);
Tentando adicionar usuário [1] na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = '1' WHERE "RoomPlayer"."roomId" = 16;
Adicionando usuário [174] à sala [3]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: 3
Adicionando usuário [174] para a sala [3] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 16;
Enviando mensagem do sistema [1 tá na área!] para a sala [3]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
Pegando player do usuário [174] na sala [16]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 16 AND "RoomPlayer"."userId" = 174);
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Selecionando estado do deck [nudes] para a sala [16]
Adicionando o deck [nudes] da sala [16]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Selecionando estado do deck [euro] para a sala [16]
Adicionando o deck [euro] da sala [16]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Selecionando estado do deck [dixit] para a sala [16]
Adicionando o deck [dixit] da sala [16]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [deck-victory] para a sala [[object SequelizeInstance:Room]]
Executing (default): UPDATE "rooms" SET "victory"=$1,"updatedAt"=$2 WHERE "id" = $3
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [deck-victory] para a sala [[object SequelizeInstance:Room]]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [deck-victory] para a sala [[object SequelizeInstance:Room]]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [deck-victory] para a sala [[object SequelizeInstance:Room]]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [deck-victory] para a sala [[object SequelizeInstance:Room]]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [points-victory] para a sala [[object SequelizeInstance:Room]]
Executing (default): UPDATE "rooms" SET "victory"=$1,"updatedAt"=$2 WHERE "id" = $3
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [points-victory] para a sala [[object SequelizeInstance:Room]]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Selecionando estado do deck [nudes] para a sala [16]
Adicionando o deck [nudes] da sala [16]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Selecionando estado do deck [euro] para a sala [16]
Adicionando o deck [euro] da sala [16]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Selecionando estado do deck [peq] para a sala [16]
Removendo o deck [peq] da sala [16]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Selecionando estado do deck [euro] para a sala [16]
Adicionando o deck [euro] da sala [16]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [deck-victory] para a sala [[object SequelizeInstance:Room]]
Executing (default): UPDATE "rooms" SET "victory"=$1,"updatedAt"=$2 WHERE "id" = $3
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [deck-victory] para a sala [[object SequelizeInstance:Room]]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [deck-victory] para a sala [[object SequelizeInstance:Room]]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Configurando a condição de vitória como [deck-victory] para a sala [[object SequelizeInstance:Room]]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [173]
emitindo roomData para o socket [sP6FuitFpUaFf2-9AAAB] do usuário [173]
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
O jogador [173] está iniciando o jogo na sala [3]
Os decks do jogo são [[ 'peq' ]] e a condicao de vitoria é [deck-victory]
usuário [173] está tentando iniciar o jogo na sala [3] com menos jogadores [1] que o minimo [2]
Não foi possível começar o jogo: Você precisa de pelo menos 2 jogadores para começar!
Usuário [173] com socket [sP6FuitFpUaFf2-9AAAB] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 185
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 173 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 173 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 173;
Enviando mensagem do sistema [2 meteu o pé.] para a sala [3]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 16 AND "RoomPlayer"."userId" = 173);
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
checando se o jogador atual está na última posição da fila.
jogador atual na última posição. Alterando o currentPlayerIndex para 0.
removendo roomPlayer de id [59] da sala [3]
Executing (default): UPDATE "roomPlayers" SET "roomId"=$1,"updatedAt"=$2 WHERE "roomId" = $3 AND "id" IN (59)
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
emitindo RoomData para todos os sockets do usuário [173]
Agora temos [1] usuários na sala
Executing (default): INSERT INTO "sockets" ("id","socketId","createdAt","updatedAt") VALUES (DEFAULT,$1,$2,$3) RETURNING *;
[io.on('connect') - Nova socket conectada com id [iXzi3ENlj7yTAgy4AAAD]
Conteúdo de handshake da socket [iXzi3ENlj7yTAgy4AAAD]: {
  "headers": {
    "host": "localhost:5000",
    "user-agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:85.0) Gecko/20100101 Firefox/85.0",
    "accept": "*/*",
    "accept-language": "en-US,en;q=0.5",
    "accept-encoding": "gzip, deflate",
    "origin": "http://localhost:3000",
    "connection": "keep-alive",
    "referer": "http://localhost:3000/GameRoom/3",
    "cookie": "jenkins-timestamper-offset=10800000; connect.sid=s%3AOcF_PoN7c86xTKvEUcYxy0GX1Ch4wAtd.8CVgCeeDx0YPxWQsXTW7YNI1MAGvVMMl0%2FZnQD94vzY; io=sP6FuitFpUaFf2-9AAAB"
  },
  "time": "Sun Feb 14 2021 19:09:12 GMT-0300 (Brasilia Standard Time)",
  "address": "::ffff:127.0.0.1",
  "xdomain": true,
  "secure": false,
  "issued": 1613340552182,
  "url": "/socket.io/?EIO=3&transport=polling&t=NUYbolp",
  "query": {
    "EIO": "3",
    "transport": "polling",
    "t": "NUYbolp"
  }
}
Conteúdo da sessão da socket [iXzi3ENlj7yTAgy4AAAD]: {
  "cookie": {
    "originalMaxAge": 2592000000,
    "expires": "2021-03-16T22:09:12.181Z",
    "httpOnly": true,
    "path": "/"
  }
}
A socket com id [iXzi3ENlj7yTAgy4AAAD] é um novo usuário, criando novo usuário!
Criando um novo usuário!
Executing (default): INSERT INTO "users" ("id","createdAt","updatedAt") VALUES (DEFAULT,$1,$2) RETURNING *;
User {
  dataValues: {
    id: 175,
    updatedAt: 2021-02-14T22:09:12.190Z,
    createdAt: 2021-02-14T22:09:12.190Z,
    name: null
  },
  _previousDataValues: {
    id: 175,
    name: null,
    createdAt: 2021-02-14T22:09:12.190Z,
    updatedAt: 2021-02-14T22:09:12.190Z
  },
  _changed: { id: false, name: false, createdAt: false, updatedAt: false },
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: null,
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Users', singular: 'User' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'users',
    hooks: {}
  },
  _options: {
    isNewRecord: true,
    _schema: null,
    _schemaDelimiter: '',
    attributes: undefined,
    include: undefined,
    raw: undefined,
    silent: undefined
  },
  isNewRecord: false
}
Novo usuário criado: 175
Usuário adicionado, agora temos [4] usuário(s)
Salvando sessao da socket [iXzi3ENlj7yTAgy4AAAD]:  Session {
  cookie: {
    path: '/',
    _expires: 2021-03-16T22:09:12.181Z,
    originalMaxAge: 2592000000,
    httpOnly: true
  },
  userId: 175
}
Ligando o usuário [175] ao socket [187]
Executing (default): SELECT "id" FROM "sockets" AS "Socket" WHERE ("Socket"."userId" = 175 AND (("Socket"."id" = 187)));
Executing (default): UPDATE "sockets" SET "userId"=$1,"updatedAt"=$2 WHERE "id" IN (187)
Executing (default): SELECT COUNT("Socket"."id") AS "count" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 175;
Usuário [175] ligado ao socket [187], agora ele tem [1] socket(s)
Enviando dados de sessão para o usuário [175]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 175 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 175 ) ON "Room"."id" = "players"."roomId";
sala [NÃO ENCONTRADA NA QUERY] encontrada
verificando se existem dados de partida para o usuário
Usuário [175] tentando entrar com nome [2] na sala com nome [3]
retornando a sala do jogador [null] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 175 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 175 ) ON "Room"."id" = "players"."roomId";
Usuário [175] trocou o nome de [null] para [2]
Executing (default): UPDATE "users" SET "name"=$1,"updatedAt"=$2 WHERE "id" = $3
Buscando uma sala com nome [3]
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE "Room"."name" = '3' LIMIT 1) AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id";
Room {
  dataValues: {
    id: 16,
    state: 'WAITING_FOR_PLAYERS',
    name: '3',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'deck-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T22:01:22.102Z,
    updatedAt: 2021-02-14T22:06:55.697Z,
    hostId: 173,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _previousDataValues: {
    id: 16,
    state: 'WAITING_FOR_PLAYERS',
    name: '3',
    turn: 1,
    currentPlayerIndex: 0,
    prompt: null,
    selectedCardCount: 0,
    victory: 'deck-victory',
    votingCardsTurn: [],
    winner: [],
    minimumPlayersToStart: 2,
    minimumCardsToStart: 50,
    selectedDecksIds: [ 'peq' ],
    deck: [],
    morto: [],
    results: '[]',
    createdAt: 2021-02-14T22:01:22.102Z,
    updatedAt: 2021-02-14T22:06:55.697Z,
    hostId: 173,
    players: [ [RoomPlayer] ],
    host: User {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false
    }
  },
  _changed: {},
  _modelOptions: {
    timestamps: true,
    validate: {},
    freezeTableName: false,
    underscored: false,
    paranoid: false,
    rejectOnEmpty: false,
    whereCollection: { name: '3' },
    schema: null,
    schemaDelimiter: '',
    defaultScope: {},
    scopes: {},
    indexes: [],
    name: { plural: 'Rooms', singular: 'Room' },
    omitNull: false,
    underscore: true,
    sequelize: Sequelize {
      options: [Object],
      config: [Object],
      dialect: [PostgresDialect],
      queryInterface: [QueryInterface],
      models: [Object],
      modelManager: [ModelManager],
      connectionManager: [ConnectionManager],
      importCache: {}
    },
    tableName: 'rooms',
    hooks: {}
  },
  _options: {
    isNewRecord: false,
    _schema: null,
    _schemaDelimiter: '',
    include: [ [Object], [Object] ],
    includeNames: [ 'players', 'host' ],
    includeMap: { players: [Object], host: [Object] },
    includeValidated: true,
    attributes: [
      'id',                    'state',
      'name',                  'turn',
      'currentPlayerIndex',    'prompt',
      'selectedCardCount',     'victory',
      'votingCardsTurn',       'winner',
      'minimumPlayersToStart', 'minimumCardsToStart',
      'selectedDecksIds',      'deck',
      'morto',                 'results',
      'createdAt',             'updatedAt',
      'hostId'
    ],
    raw: true
  },
  isNewRecord: false,
  players: [
    RoomPlayer {
      dataValues: [Object],
      _previousDataValues: [Object],
      _changed: {},
      _modelOptions: [Object],
      _options: [Object],
      isNewRecord: false,
      playerOwner: [User]
    }
  ],
  host: User {
    dataValues: {
      id: 173,
      name: '2',
      createdAt: 2021-02-14T22:01:13.245Z,
      updatedAt: 2021-02-14T22:01:22.081Z
    },
    _previousDataValues: {
      id: 173,
      name: '2',
      createdAt: 2021-02-14T22:01:13.245Z,
      updatedAt: 2021-02-14T22:01:22.081Z
    },
    _changed: {},
    _modelOptions: {
      timestamps: true,
      validate: {},
      freezeTableName: false,
      underscored: false,
      paranoid: false,
      rejectOnEmpty: false,
      whereCollection: null,
      schema: null,
      schemaDelimiter: '',
      defaultScope: {},
      scopes: {},
      indexes: [],
      name: [Object],
      omitNull: false,
      underscore: true,
      sequelize: [Sequelize],
      tableName: 'users',
      hooks: {}
    },
    _options: {
      isNewRecord: false,
      _schema: null,
      _schemaDelimiter: '',
      include: undefined,
      includeNames: undefined,
      includeMap: undefined,
      includeValidated: true,
      raw: true,
      attributes: undefined
    },
    isNewRecord: false
  }
}
A sala [3] que o usuário [175] está tentando acessar já existe, colocando ele como jogador!
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 16 AND "RoomPlayer"."userId" = 175);
Tentando adicionar usuário [2] na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" INNER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" AND "playerOwner"."name" = '2' WHERE "RoomPlayer"."roomId" = 16;
Adicionando usuário [175] à sala [3]
Executing (default): INSERT INTO "roomPlayers" ("id","score","turnScore","hand","mySelectedCard","selectedCard","votedCard","createdAt","updatedAt","userId","roomId") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
Sala atual é: 3
Adicionando usuário [175] para a sala [3] no socket
Executing (default): SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId", "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt", "host"."id" AS "host.id", "host"."name" AS "host.name", "host"."createdAt" AS "host.createdAt", "host"."updatedAt" AS "host.updatedAt" FROM "rooms" AS "Room" LEFT OUTER JOIN "roomPlayers" AS "players" ON "Room"."id" = "players"."roomId" LEFT OUTER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" LEFT OUTER JOIN "users" AS "host" ON "Room"."hostId" = "host"."id" WHERE "Room"."id" = 16;
Enviando mensagem do sistema [2 tá na área!] para a sala [3]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
emitindo RoomData para todos os sockets do usuário [174]
emitindo roomData para o socket [Fce5mfVQkpLWCYrwAAAC] do usuário [174]
emitindo RoomData para todos os sockets do usuário [175]
emitindo roomData para o socket [iXzi3ENlj7yTAgy4AAAD] do usuário [175]
Pegando player do usuário [175] na sala [16]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 16 AND "RoomPlayer"."userId" = 175);
Usuário [174] com socket [Fce5mfVQkpLWCYrwAAAC] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 186
retornando a sala do jogador [1] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 174 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 174 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 174;
Enviando mensagem do sistema [1 meteu o pé.] para a sala [3]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 16 AND "RoomPlayer"."userId" = 174);
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
checando se o jogador atual está na última posição da fila.
jogador atual na última posição. Alterando o currentPlayerIndex para 0.
removendo roomPlayer de id [60] da sala [3]
Executing (default): UPDATE "roomPlayers" SET "roomId"=$1,"updatedAt"=$2 WHERE "roomId" = $3 AND "id" IN (60)
emitindo RoomData para todos os sockets do usuário [175]
emitindo roomData para o socket [iXzi3ENlj7yTAgy4AAAD] do usuário [175]
emitindo RoomData para todos os sockets do usuário [174]
Agora temos [1] usuários na sala
Usuário [175] com socket [iXzi3ENlj7yTAgy4AAAD] desconectou do servidor
Executing (default): DELETE FROM "sockets" WHERE "id" = 187
retornando a sala do jogador [2] se ele estiver em uma
Executing (default): SELECT "Room".*, "players"."id" AS "players.id", "players"."score" AS "players.score", "players"."turnScore" AS "players.turnScore", "players"."hand" AS "players.hand", "players"."mySelectedCard" AS "players.mySelectedCard", "players"."selectedCard" AS "players.selectedCard", "players"."votedCard" AS "players.votedCard", "players"."createdAt" AS "players.createdAt", "players"."updatedAt" AS "players.updatedAt", "players"."userId" AS "players.userId", "players"."roomId" AS "players.roomId", "players->playerOwner"."id" AS "players.playerOwner.id", "players->playerOwner"."name" AS "players.playerOwner.name", "players->playerOwner"."createdAt" AS "players.playerOwner.createdAt", "players->playerOwner"."updatedAt" AS "players.playerOwner.updatedAt" FROM (SELECT "Room"."id", "Room"."state", "Room"."name", "Room"."turn", "Room"."currentPlayerIndex", "Room"."prompt", "Room"."selectedCardCount", "Room"."victory", "Room"."votingCardsTurn", "Room"."winner", "Room"."minimumPlayersToStart", "Room"."minimumCardsToStart", "Room"."selectedDecksIds", "Room"."deck", "Room"."morto", "Room"."results", "Room"."createdAt", "Room"."updatedAt", "Room"."hostId" FROM "rooms" AS "Room" WHERE ( SELECT "players"."roomId" FROM "roomPlayers" AS "players" INNER JOIN "users" AS "playerOwner" ON "players"."userId" = "playerOwner"."id" AND "playerOwner"."id" = 175 WHERE ("players"."roomId" = "Room"."id") LIMIT 1 ) IS NOT NULL LIMIT 1) AS "Room" LEFT OUTER JOIN ( "roomPlayers" AS "players" INNER JOIN "users" AS "players->playerOwner" ON "players"."userId" = "players->playerOwner"."id" AND "players->playerOwner"."id" = 175 ) ON "Room"."id" = "players"."roomId";
Executing (default): SELECT "id", "socketId", "createdAt", "updatedAt", "userId", "roomId" FROM "sockets" AS "Socket" WHERE "Socket"."userId" = 175;
Enviando mensagem do sistema [2 meteu o pé.] para a sala [3]
Emitindo roomData para os sockets conectados na sala [3]
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" WHERE ("RoomPlayer"."roomId" = 16 AND "RoomPlayer"."userId" = 175);
Executing (default): SELECT "RoomPlayer"."id", "RoomPlayer"."score", "RoomPlayer"."turnScore", "RoomPlayer"."hand", "RoomPlayer"."mySelectedCard", "RoomPlayer"."selectedCard", "RoomPlayer"."votedCard", "RoomPlayer"."createdAt", "RoomPlayer"."updatedAt", "RoomPlayer"."userId", "RoomPlayer"."roomId", "playerOwner"."id" AS "playerOwner.id", "playerOwner"."name" AS "playerOwner.name", "playerOwner"."createdAt" AS "playerOwner.createdAt", "playerOwner"."updatedAt" AS "playerOwner.updatedAt", "playerOwner->sockets"."id" AS "playerOwner.sockets.id", "playerOwner->sockets"."socketId" AS "playerOwner.sockets.socketId", "playerOwner->sockets"."createdAt" AS "playerOwner.sockets.createdAt", "playerOwner->sockets"."updatedAt" AS "playerOwner.sockets.updatedAt", "playerOwner->sockets"."userId" AS "playerOwner.sockets.userId", "playerOwner->sockets"."roomId" AS "playerOwner.sockets.roomId" FROM "roomPlayers" AS "RoomPlayer" LEFT OUTER JOIN "users" AS "playerOwner" ON "RoomPlayer"."userId" = "playerOwner"."id" LEFT OUTER JOIN "sockets" AS "playerOwner->sockets" ON "playerOwner"."id" = "playerOwner->sockets"."userId" WHERE "RoomPlayer"."roomId" = 16;
checando se o jogador atual está na última posição da fila.
jogador atual na última posição. Alterando o currentPlayerIndex para 0.
removendo roomPlayer de id [61] da sala [3]
emitindo RoomData para todos os sockets do usuário [175]
Executing (default): UPDATE "roomPlayers" SET "roomId"=$1,"updatedAt"=$2 WHERE "roomId" = $3 AND "id" IN (61)
Agora temos [1] usuários na sala
